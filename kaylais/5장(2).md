## 5. 모놀리스 분해하기  

### 트랜잭션의 경계  
애플리케이션 코드를 완전히 불리하여 각각의 마이크로서비스로 만들기 전에, 서비스는 이전과 같이 하나로 유지한 채 우선 스키마 분리를 추천  
서비스를 단계적으로 분리  
연산의 일부를 큐나 로그 파일에 큐잉하여 나중에 재시도 할 수 있음  

**보상 트랜잭션(compensating transaction)**  
직전의 트랜잭션을 되돌릴 새로운 트랜잭션을 발생시키는 것  

**분산 트랜잭션(distributed transaction)**  
보상 트랜잭션을 수동으로 통제하는 방식의 대안  
2단계 커밋(two-phase commit)  

### 데이터베이스 리팩토링  
모든 코드를 병합하기 전에는 관심사들이 실제로 통합되었는지 명확하지 않음  
다르게 저장될 수 있는 분리된 두 가지 개념이 있음  

### 리포팅 데이터베이스  
일반적인 모놀리식 서비스 아키텍처에서 모든 데이터는 거대한 단일 데이터베이스에 저장됨  
모든 데이터가 한 곳에 모여 있어서 모든 정보의 경계를 넘어서 리포팅하는 것이 실제로 매우 쉽다  
SQL 질의와 그와 유사한 것들을 통해 데이터를 쉽게 조인할 수 있기 때문  
리포팅 질의가 메인 시스템의 성능에 영향을 주는 것을 우려하여  
리포트를 메인 데이터베이스에서 실행하지 않을 것  
이에 리포팅 시스템은 대게 읽기용 복제 데이터베이스(read replica)에 연결됨  

#### 서비스 호출을 통한 데이터 추출  
- 데이터베이스 스키마는 실행 중인 모놀리식 서비스와 리포팅 시스템 사이에서 사실상 공유 API임  
	- 스키마의 변경은 조심스럽게 관리되어야 하며, 실제로 이것은 스키마를 변경하고 조율할 기회를 줄이는 방해물  
- 실제 시스템 또는 리포팅 시스템을 지원하는 사용 사례를 위해 데이터베이스를 최적하는 방법은 제한적  
	- 데이터 구조 변경이 실행 중인 시스템에 악영향을 주더라도 리포팅을 빠르게 하기 위해 데이터를 다르게 구성할 수 없음  
	- 스키마가 한 사용 사례에는 훌륭하게 들어맞지만 다른 사례에는 그렇지 못하거나 두 사례의 목적과 부합하지 않아 최소한의 공통분모만 가지게 되는 것  
- 일반적인 관계형 데이터베이스가 많은 리포팅 도구와 호환되는 SQL 질의 인터페이스를 제공하더라도 동작 중인 서비스에 데이터를 저장하기 위한 최선의 방법은 아님  

#### 데이터 덤프  
(TBU)  


---

