## 5. 모놀리스 분해하기  

### 트랜잭션의 경계  
애플리케이션 코드를 완전히 불리하여 각각의 마이크로서비스로 만들기 전에, 서비스는 이전과 같이 하나로 유지한 채 우선 스키마 분리를 추천  
서비스를 단계적으로 분리  
연산의 일부를 큐나 로그 파일에 큐잉하여 나중에 재시도 할 수 있음  

**보상 트랜잭션(compensating transaction)**  
직전의 트랜잭션을 되돌릴 새로운 트랜잭션을 발생시키는 것  

**분산 트랜잭션(distributed transaction)**  
보상 트랜잭션을 수동으로 통제하는 방식의 대안  
2단계 커밋(two-phase commit)  

### 데이터베이스 리팩토링  
모든 코드를 병합하기 전에는 관심사들이 실제로 통합되었는지 명확하지 않음  
다르게 저장될 수 있는 분리된 두 가지 개념이 있음  

### 리포팅 데이터베이스  
일반적인 모놀리식 서비스 아키텍처에서 모든 데이터는 거대한 단일 데이터베이스에 저장됨  
모든 데이터가 한 곳에 모여 있어서 모든 정보의 경계를 넘어서 리포팅하는 것이 실제로 매우 쉽다  
SQL 질의와 그와 유사한 것들을 통해 데이터를 쉽게 조인할 수 있기 때문  
리포팅 질의가 메인 시스템의 성능에 영향을 주는 것을 우려하여  
리포트를 메인 데이터베이스에서 실행하지 않을 것  
이에 리포팅 시스템은 대게 읽기용 복제 데이터베이스(read replica)에 연결됨  

#### 서비스 호출을 통한 데이터 추출  
- 데이터베이스 스키마는 실행 중인 모놀리식 서비스와 리포팅 시스템 사이에서 사실상 공유 API임  
	- 스키마의 변경은 조심스럽게 관리되어야 하며, 실제로 이것은 스키마를 변경하고 조율할 기회를 줄이는 방해물  
- 실제 시스템 또는 리포팅 시스템을 지원하는 사용 사례를 위해 데이터베이스를 최적하는 방법은 제한적  
	- 데이터 구조 변경이 실행 중인 시스템에 악영향을 주더라도 리포팅을 빠르게 하기 위해 데이터를 다르게 구성할 수 없음  
	- 스키마가 한 사용 사례에는 훌륭하게 들어맞지만 다른 사례에는 그렇지 못하거나 두 사례의 목적과 부합하지 않아 최소한의 공통분모만 가지게 되는 것  
- 일반적인 관계형 데이터베이스가 많은 리포팅 도구와 호환되는 SQL 질의 인터페이스를 제공하더라도 동작 중인 서비스에 데이터를 저장하기 위한 최선의 방법은 아님  

#### 데이터 덤프  
리포팅 시스템이 데이터를 끌어오는 방식 대신 리포팅 시스템에 데이터를 밀어 넣는 방식을 시도할 수 있다.   
일반적인 HTTP 호출로 데이터를 추출하는 데 있어 단점 중 하나는 다수의 호출을 할 때 발생하는 HTTP의 부하고  
리포팅 목적으로만 사용될지도 모르는 API를 만들어야 하는 부담이다. 
-> 같은 데이터의 소스인 서비스의 데이터베이스에 직접 접근하여 리포팅 데이터베이스로 밀어 넣는 독립 프로그램을 가지는 것 

**데이터마트**  
AWS S3를 실제로 거대한 데이터 마트로 위장하며, JSON 파일을 S3에 저장하기 위해 데이터 펌프를 사용함  
-> 솔루션이 확장이 필요할 때까지 아주 효과가 있었고, 엑셀과 태블로 같은 표준 리포팅 도구와 통합할 수 있는 큐브를 채우도록 이 펌프들을 변경하는 것을 검토  

#### 이벤트 데이터 펌프   
고객 서비스가 상태가 바뀌면 상태 변이 이벤트가 발행되고 고객 리포팅 맵퍼를 통해 중앙의 리포팅 데이터베이스로 펌프 됨  




---

**Cassandra**  
컬럼 지향 데이터베이스(column-oriented database)로 대용량 확장이 매우 용이한 리포팅 시스템에 적합  
컬럼 지향 데이터베이스는 데이터를 열 단위로 저장  
