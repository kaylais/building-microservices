## 6. 배포  

지속적 통합과 지속적 배포를 살펴보자  

### 지속적 통합(CI/Continuous Integration)  
- CI를 통한 핵심 목표는 모든 사람이 서로 동기를 맞추는 것  
- 새롭게 체크인된 코드가 기존 코드와 적절히 통합됨을 보장함으로 달성할 수 있음  
- CI 서버는 아래에 대한 검증을 함  
  - 코드의 커밋을 감지  
  - 체크아웃  
  - 코드의 컴파일과 테스트 통과를 확인  

### CI 장점  
- 코드 품질에 대해 어느 정도 바른 피드백을 얻을 수 있음  
- 바이너리 산출물을 자동으로 생성  
  - 산출물의 빌드를 위한 모든 코드는 버전 관리 되므로 필요할 때 언제든지 다시 만들 수 있음  
  - 배포된 산출물의 코드를 찾을 수 있는 정도로 추적할 수 있음  
  - CI 도구 자체의 기능에 따라 코드와 산출물에 대해 어떤 테스트가 수행되었는지 확인 가능  

### 제즈 험블의 3가지 질문  
CI는 빠르고 신속한 변경을 위한 핵심적인 실천 사항  
CI 없이는 마이크로서비스를 향한 여정이 고통스러울 것  
CI 도구의 사용과 CI의 실천을 혼동하지 말 것  
CI 도구는 단지 이러한 접근을 가능하게 할 뿐  

- Q.하루에 한번 메인 브랜치에 체크인하는가?  
  - 여러분은 자신의 코드를 통합하는지 확인할 필요가 있다. 여러분 코드는 물론 다른 사람들이 변경한 코드 또한 자주 확인하지 않는다면 향후의 통합이 더 어려워진다. 여러분이 변경을 위해 단기 브랜치를 사용하고 있더라도 가능한 한 자주 메인 브랜치에 통합하라.  
- Q.변경을 확인할 테스트 집합이 있는가?  
  - 테스트를 하지 않는다면 통합해서 작동하는지 구문상으로만 알 수 있으며, 시스템의 동작을 중단시키는 것까지는 알 수 없다. 코드가 기대한 대로 동작하는지 검증하지 않는 CI는 CI가 아니다.  
- Q.빌드가 깨졌을 때 팀이 그것을 최우선으로 해결하는가?  
  - 녹색 빌드는 변경한 것이 안전하게 통합되었고, 적색 빌드는 마지막 변경이 통합되지 않았음을 의미한다. 우리는 빌드 문제의 해결과 관련 없는 추가적인 체크인을 중단해야 한다. 변경이 많이 적체되면 그 빌드를 해결할 시간이 급격히 늘어난다. 필자는 수일 동안 필드가 깨어진 채로 방치한 티과 함께 작업했었는데, 결국 빌드를 통화하는 데 엄청난 노력이 들었다.  

### CI를 마이크로서비스와 매핑하기  
실환경에 배포하기 전에 신속히 변경하고 확인할 수 있도록 마이크로서비스당 하나의 CI 빌드를 두는 것  
각 마이크로서비스는 각자의 CI 빌드에 매핑된 각각의 소스 코드 저장소를 가진다.
팀의 소유권도 훨씬 명확히 정리되나. 즉, 서비스의 소유는 저장소와 빌드도 책임지는 것을 의미  
특정 마이크로서비스에 대해 어떤 테스트가 수행되어야 하는지 언제든지 알 수 있도록 테스트는 마이크로서비스 소스 코드가 있는 소스 컨트롤 시스템에 있어야 함  


### 빌드 파이프라인  
각 단계를 완료하면서 소프트웨어 과정을 추적하는 방법을 제공, 소프트웨어 품질에 대한 통찰력을 가지도록 도움
**CD** 는 모든 체크인의 실환경 준비에 대한 지속적인 피드백을 얻고, 나아가 모든 체크인을 빠짐없이 릴리스 후보로 여기는 접근 방법  
체크인에서 실환경까지 소프트웨어를 입수하는 데 연관된 모든 프로세스를 모델링해야 하고,  
어떤 버전의 소프트웨어가 릴리스에 적용되었는지 알아야 한다.  
CD에서는 소프트웨어가 진행하는 수동과 자동화의 모든 단계를 모델링하는 다단게 빌드 파이프라인의 개념을 확장하여 이것을 수행한다.  

TBU  
