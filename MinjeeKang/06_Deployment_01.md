배포
===
> 모놀리식 애플리케이션 배포 과정은 단순하지만 <br/>
> 상호 의존성을 가진 마이크로서비스의 배포는 모놀로식과 전혀 다르다.

<br/><br/>

### 지속적 통합 (continuous Integration)
모든 사람이 서로 동기를 맞추는 것이 핵심목표 <br />
-> 새롭게 체크인된 코드가 기존 코드와 적절히 통합됨을 보장함으로써 달성<br />
이를위해 CI서버는 코드의 커밋을 감지, 체크아웃, 코드의 컴파일과 테스트 통과를 확인하는 것과 같은 몇가지 검증을 한다
> CI의 혜택<br />
> 1. 코드 품질에 대해 어느 정도 빠른 피드백
> 2. 바이너리 산출물 자동 생성
> 3. 산출물 빌드를 위한 모든 코드를 버전관리 해 필요할 때 언제든 다시 만들 수 있음
> 4. 배출된 산출물 코드 추적
> 5. CI 도구 자체 기능에 따라 코드, 산출물에 대해 어떤 테스트가 수행되었는지 확인 가능
1. 정말로 하고 있는가<br/>
제즈 험블의 3가지 질문 - CI를 정말로 이해하고 있는지 테스트하기 위한...
>> 1. 하루에 한번 메인 브랜치에 체크인 하는가?
>> 2. 변경을 확인할 테스트 집합이 있는가?
>> 3. 빌드가 깨졌을 때 팀이 그 것을 최우선으로 해결하는가?
***
<br/>

### 지속적 통합을 마이크로서비스로 매핑하기
> 마이크로서비스와 지속적 통합을 생각할 때 CI 빌드와 어떻게 개별 마이크로서비스와 매핑할 것인지 생각해야함

1. __모든 마이크로서비스를 위해 단일 저장소와 CI빌드 사용_
>> 소스 코드 저장소에 어떠한 체크인도 빌드를 작동시킬 것, 그 빌드를 통해 모든 마이크로서비스와 연관된 검증 단계 수행 후 다수의 산출물 생성 -> 모두 동일한 빌드로 묶여있음<br />
>> 신경 쓸 저장소가 적을 수록 빌드도 개념적으로 단순, 개발자 관점에서도 직관적<br />
>> 단점 - 한 서비스 내 한 줄 코드 변경 시에도 모든 서비스가 검증, 빌드, 전체 테스트 등 필요 이상의 시간 소요로 순환 시간에 영향 / 어떤 산출물이 배포되고 되지 않아야 하는지 알기 어려움<br />
>> -> 전적으로 피해야할 패턴이나 프로젝트 초기, 특히 한 팀이 모든 작업을 한다면 짧은 기간동안 적잘한 모델
2. __독립된 빌드와 매핑된 서브디렉터리를 가진 단일 소스 저장소__<br/>
>> 명확한 소스 구조를 통해 빌드를 소스 코드의 특저 부분과 쉽게 매핑<br/>
3. __마이크로서비스 당 하나의 코드 저장소와 CI빌드 사용하기__
>> 각 마이크로서비스는 각자의 CI 빌드에 매핑된 각각 소스 코드 저장소를 가져 코드 변경 발생 시, 필요한 필드, 테스트만 수행, 배퐇라 하나의 산출물만 얻음
***
<br/>

### 빌드 파이프라인과 지속적 배포
빌드 파이프라인 개념은 각 단계를 완료하면서 소프트웨어 과정을 추적하는 훌령한 방법을 제공, 소프트웨어 품질에 대한 통찰력을 가지도록 함<br/>
지속적 배포(continuous delivery / CD)는 모든 체크인의 실환경 준비에 대한 지속적인 피드백을 얻고 나아가 모든 체크인을 빠짐없이 릴리즈 후보로 여기는 접근 방법<br/>
CD에서는 소프트웨어가 진행하는 수동, 자동화의 모든 단계를 모델링하는 다단계 별도 파이프라인의 개념을 환장하여 이것을 수행

> 빌드 파이프라인으로 모델링된 표준 릴리스 프로세스<br/>
> 컴파일&빠른테스트 -> 느린 테스트 -> UAT(사용자 인수 테스트) -> 성능 테스팅 -> 실환경<br/>

> 서비스가 독립적으로 릴리스하기 원하는 마이크로서비스 세계에서는 CI 와 마찬가지로 서비스 당 하나의 파이프라인을 원할 것! <br/>
> 이 파이프라인을 통해 산출물이 생성, 실환경까지 보내진다

1. 그리고 피할 수 없는 예외
'빌드 당 하나의 마이크로서비스' 방법은 전적으로 지향'<br/>
그러나 신규 프로젝트를 막 시작할 때 등 서비스 경계를 확정하는 동안 많은 혼돈을 겪기 쉽기 때문에 도메인에 대해 충분히 이해할 때까지 초창기 서비스를 큰 부분으로 유지하는 것이 좋음<br/>
__모든 서비스를 하나의 번들로 릴리스할 필요가 있게 되더라도, 이는 전적으로 과도기 단계에서만 해당__<br/>
__서비스 API들이 안정화될 때 그들을 각각의 빌드로 분리하기 시작하라!__
***
<br/>

### 플랫폼별 산출물
대부분의 기술 스택은 산출물을 생성, 설치파는 도구와 함께 훌륭한 산출물 형태를 가지고 있음
> 루비 gem, 자바 jar file / war file, 파이썬 gee 등

마이크로서비스 관점에서 사용하는 기술 스택에 따라 이 산출물 자체 만으로 부족할 수 있어 산출물을 배포, 실행하기 위해 다른 소프트웨어를 설치, 구성할 방법 필요<br />
(산출물이 특정 기술 스택에 한정, 여러 기술이 혼용될 때 배포가 어려움)
***
<br/>

### 운영체계 산출물
특정 기술에 제한적인 산출물과 관련 문제를 피할 수 있는 방법은...<br />
하부 운영 체계에 네이티브한 산출물을 생성하는 것 <br />
> 예 : 레드햇, CentOS 기반 시스템에서는 RPM, 우분투에서는 deb 패키지, 윈도우에서는 MSI를 빌드

단점<br />
1. 처음 패키지 생성 시, 어려움
2. 다양한 운영체제 배포 시, 다른 운영체제 산출물을 관리하는 작업의 부담
***
<br/>

### 커스텀 이미지
소프트웨어 설치 전 모든 필수 구성 요소 설치까지 기다려야 하기 때문에 시스템이 제로-다운타임을 허용하지 않는다면 실환경 배포 시, 다운타임이 늘어날 수 있음<br />
-> 예) 자바 어플리케이션 실행을 위한 오라클 JVM 설치(약 5분가량 시간 소요)<br />
> 기동시간을 줄이기 위한 방법은 공통적으로 의존하는 것들을 주입한 가상 머신 이미지를 만드는 것<br />
> 예) 소프트웨어 배포를 할 경우 커스텀 이미지의 인스턴스 가동 후 서비스 최신 버전 설치 <br />
> -> 이미지를 한 번만 빌드하기 때문에 이미지의 복제본 연속 실행 시, 그것들을 설치하는 시간이 필요 없음<br /><br />
> 단점<br />
> * 이미지 생성 시간이 오래 소요될 수 있음
> * 생성된 이미지가 클 수 있음

1. 산출물로서의 이미지<br />
서비스를 이미지 안에 구워내고 서비스 산출물이 이미지가 되는 모델 적용<br />
예) 빠른 가동 시간으로 인해 넷플릭스는 자신들의 서비스를 AWS AML로 생성하는 모델 채택
2. 불변 서버<br />
실행 중인 서버에 어떠한 변경도 하지 않고 아주 작은 변경이라도 새로운 머신을 생성하기 위해서는 빌드 파이프라인을 통해야 함
***
<br/>

### 환경
실환경은 두 개의 데이터 센터에서 다수의 부하 분산용 호스트로 구성될 수 있는 반면, <br />
테스트 환경은 하나의 호스트에 의해 운영될 수 있어 이런 환경의 차이는 문제를 야기할 수 있음
***

### 서비스 환경 구성
> 이상적으로 환경 구성은 작아야하며<br/>
> 환경마다 변경해야 하는 제한된 기능이 되고 이는 전적으로 최소화 되어야 함

서비스 환경마다 바뀌워야 하는 환경 구성일 때 배포 프로세스의 일부로 다루는 방법
1. 환경당 하나의 산출물을 빌드하고 환경 구성을 그 산출물에 포함
2. 단일 산출물을 생성, 환경 구성을 분리해서 관리
***
<br/>

### 서비스의 호스트 매핑
직접 물리적인 머신을 배포하고 있다면 물리적인 서버는 하나의 호스트로 매핑
1. 호스팅당 다수의 서비스<br />
다수의 서비스가 매력적인 이유<br />
-> 전적으로 호스트 관리 관점에서 볼 때 더 단순 / 비용 절감 / 여러 형태의 애플리케이션 컨테이너에 배포하는 사람들에게 친숙<br />
문제점 : <br />
-> 모니터링이 어려움 / 부하로 인한 부작용 / 서비스 배포의 복잡성 / 팀의 자율성 저해 / 배포 산출물의 방식 제한<br />
2. 애플리케이션 컨테이너<br />
애플리케이션 컨터이너 안에 서비스가 상주하는 아이디어는 인스턴스들의 그룹화나 모니터링 도구 등을 다루는 클러스터링 자원처럼 관리성이 향상된 측면에서 많은 혜택을 지원
문제점 : <br />
필연적 기술의 제약 / 애플리케이션 수명주기를 적절히 관리하려는 시도는 문제가 많고 복잡할 수 있음<br />
__애플리케이션 컨테이너 방법은 더 이상 감당할 수 없는 자원 부족을 최적화하기 위한 시도__
3. 호스트당 단일 서비스<br />
쉬운 모니터링과 복원기능을 제공, 호스트당 다수 서비스 모델의 부작용 회피 및 잠재적으로 단일 장애 지점을 줄임<br />
특정 서비스를 다른 서비스와 독립적으로 확장할 수 있고 보안 문제와 관련, 해당 서비스와 호스트만 집중할 수 있으므로 더 쉽게 처리 가능<br />
문제점 : <br />
증가된 호스트 숫자가 잠재적인 단점
4. 서비스로서의 플랫폼(PaaS)<br />
단일 호스트보다 더 높은 수준의 추상화 대상에서 작업
문제점 : <br />
제대로 작동하지 않을 경우 문제를 고치기 위해 내부를 살펴보려는 측면에서 통제할 수 있는 것이 많지 않음
***
<br/>

### 자동화
> 지금까지 우리가 제시한 많은 문제의 해답은 결국 자동화로 귀결

자동화는 개발자가 생산성을 유지하게 만들 수 있는 방법
1. 자동화의 위력에 대한 두 가지 사례 연구<br/>
__REA (호주 아시아 태평양 지역 소매상, 기업고객에 부동산 리스트 제공 회사)__<br/>
수년동안 플랫폼을 분산된 마이크로서비스 설계로 변경<br/>
첫 3개월 : 개발팀이 전체 빌드, 배포, 서비스 지원에 대한 모든 책임을 떠안으며 단지 두 개의 마이크로서비스 실환경으로 옮김<br/>
이후 3개월동안 10~15개, 18개월 후에는 6~70개 이상의 마이크로서비스로 변환<br/>
__길트(온라인패션몰)__
모놀리식 레일즈 애플리케이션은 확장성에 어려움을 겪기 시작, 2009년에 시스템을 마이크로서비스로 분해하기로 결정<br/>
개발자를 돕는 도구인 자동화는 길트의 마이크로서비스 ㅅ용을 촉발시키는 핵심요인이 됨<br/>
1년 후 길트는 10개 정도의 마이크로서비스로 교체, 2012년까지는 100개 이상, 2014년 길트 자체 조사에서 450개 마이크로서비스가 서비스 되고 있었음.
***
<br/>

### 물리 머신에서 가상회로
> 많은 수의 호스트를 관리하는데 사용할 수 있는 핵심적 수단 중 하나는 기존의 물리 머신을 더 작은 부분으로 묶는 방법을 찾는 것
1. 전통적 가상화<br />
가상화를 사용하면 물리적인 서버를 다른 일을 수행할 수 있는 별도의 호스트로 분리할 수 있음<br />
>>>대부분의 가상화 동작 설명 -> <br />
>>>물리적 인프라스트럭처 위에 호스트 운영체제가, 운영체제 위에 하이퍼바이저로 불리는 것을 실행<br />
>>>두 가지는 주요한 역할을 하는데 1) CPI와 메모리 같은 자원을 가상 호스트로부터 물리적은 호스트로 매핑 2) 우리가 가상 머신을 조작하도록 통계 계층과 같은 역할 
2. 베이크런트<br />
일반적으로 실환경 보다 개발과 테스트용으로 사용<br/>
랩톱에 가상의 클라우드 제공, 내부적으로 표준 가상화 시스템 사용<br />
로컬 머신 상에 실환경과 유사한 환경을 쉽게 생성하도록 도움<br />
단점 중 하나는 평범한 개발용 머신에 많은 VM을 실행한다는 것이 부담
3. 리눅스 컨터이너<br />
분리된 가상의 호스트를 구분, 통제하기 위해 하이퍼바이저 대신 다른 프로세스들을 위해 분리된 프로세스 공간을 생성<br />
각 컨테이너는 실질적으로 전체 시스템 프로세스 트리의 하위 트리, 이런 컨테이너는 커널이 할당한 물리적인 자원을 가질 수 있다<br />
리눅스 컨테이너는 무거운 가상화 머신보다 프로비저닝이 훨씬 빠르며 컨테이너의 경량성 덕분에 동일한 하드웨어에서 VM보다 더 많은 컨테이너를 실행시킬 수 있다<br />
4. 도커<br />
경량 컨테이너 상에 구축된 플랫폼<br />
VM세계에서 이미지와 동일한 의미인 애플리케이션을 생성, 배포할 수 있음 / 컨테이너 프로비저닝을 관리, 네트워킹 문제 처리, 도커 애플리케이션을 저장 및 버전 관리할 수 있도록 자체 레지스트리 개념도 제공<br />
>>> 도커는 많은 회사의 실환경에서 사용되고 있으며 많은 단점을 피할 수 있는 도구들과 함께 프로비저닝 효율성과 속도면에서 경량 컨테이너의 많은 혜택을 제공, 배포 플랫폼의 대안을 찾고 있다면 도커를 한번 살펴보기를 추천
***
<br/>

### 배포 인터페이스
어떤 것을 배포하는지 알아야 하므로 알려진 개체의 이름, 즉 마이크로서비스 이름을 제공할 필요가 있으며 마이크로서비스를 배포할 환경을 알아야 함
1. 환경 정의<br/>
많은 행동 양식이 규약에 기반<br/>
-> 예를 들어 서비스의 실행 장소와 관계없이 어떤 포트를 사용했는지 표준화 하기로 결정했고 서비스가 하나 이상의 인스턴스를 가졌을 때 자동적으로 부하 분산기를 설정<br/>
시스템을 구축하는 것은 상당한 양의 작업을 필요로 하며 이러한 노력은 초반에 발생하지만 우리가 가진 배포의 복잡성을 관리하는데 있어 필수적
***
<br/>

### 마치며
* 한 서비스를 다른 서비스와 독립적으로 릴리스할 수 있는 능력을 유지하는데 집중하고 어떤 기술을 선택하든 이 능력을 지원하는지 확인하라<br/>
 마이크로서비스 당 하나의 CI빌드가 필요하다는 것에는 변함이 없다
* 가능하다면 호스트 및 컨테이너당 단일 서비스로 옮겨가라<br/>
변경되는 부분을 더 쉽고 저비용으로 관리하기 위해 LXC 또는 도커와 같은 대체기술을 살펴보고 채택하는 어떤 기술도 자동화 문화가 모든 것을 관리하는 핵심임을 이해하라
* 배포 기술의 서택은 개발자에게 영향을 준다는 것, 그들 역시 그 것을 좋아한다는 것을 확실히 이해하라<br/>
특정 서비스를 다양하 ㄴ환경에 서비스 자체로 배포할 수 있는 도구를 만드는 것은 정말로 중요하다


이 주제를 더 깊이 연구하고자 하면 제즈 험블과 데이비드 팔리의 "신뢰할 수 있는 소프트웨어 출시"를 추천
***

