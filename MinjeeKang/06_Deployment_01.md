배포
===
> 모놀리식 애플리케이션 배포 과정은 단순하지만 <br/>
> 상호 의존성을 가진 마이크로서비스의 배포는 모놀로식과 전혀 다르다.
<br /><br />

### 지속적 통합 (continuous Integration)
모든 사람이 서로 동기를 맞추는 것이 핵심목표 <br />
-> 새롭게 체크인된 코드가 기존 코드와 적절히 통합됨을 보장함으로써 달성<br />
이를위해 CI서버는 코드의 커밋을 감지, 체크아웃, 코드의 컴파일과 테스트 통과를 확인하는 것과 같은 몇가지 검증을 한다
> CI의 혜택<br />
> 1. 코드 품질에 대해 어느 정도 빠른 피드백
> 2. 바이너리 산출물 자동 생성
> 3. 산출물 빌드를 위한 모든 코드를 버전관리 해 필요할 때 언제든 다시 만들 수 있음
> 4. 배출된 산출물 코드 추적
> 5. CI 도구 자체 기능에 따라 코드, 산출물에 대해 어떤 테스트가 수행되었는지 확인 가능
1. 정말로 하고 있는가<br/>
제즈 험블의 3가지 질문 - CI를 정말로 이해하고 있는지 테스트하기 위한...
>> 1. 하루에 한번 메인 브랜치에 체크인 하는가?
>> 2. 변경을 확인할 테스트 집합이 있는가?
>> 3. 빌드가 깨졌을 때 팀이 그 것을 최우선으로 해결하는가?
---
<br/>

### 지속적 통합을 마이크로서비스로 매핑하기
> 마이크로서비스와 지속적 통합을 생각할 때 CI 빌드와 어떻게 개별 마이크로서비스와 매핑할 것인지 생각해야함

1. __모든 마이크로서비스를 위해 단일 저장소와 CI빌드 사용_
>> 소스 코드 저장소에 어떠한 체크인도 빌드를 작동시킬 것, 그 빌드를 통해 모든 마이크로서비스와 연관된 검증 단계 수행 후 다수의 산출물 생성 -> 모두 동일한 빌드로 묶여있음<br />
>> 신경 쓸 저장소가 적을 수록 빌드도 개념적으로 단순, 개발자 관점에서도 직관적<br />
>> 단점 - 한 서비스 내 한 줄 코드 변경 시에도 모든 서비스가 검증, 빌드, 전체 테스트 등 필요 이상의 시간 소요로 순환 시간에 영향 / 어떤 산출물이 배포되고 되지 않아야 하는지 알기 어려움<br />
>> -> 전적으로 피해야할 패턴이나 프로젝트 초기, 특히 한 팀이 모든 작업을 한다면 짧은 기간동안 적잘한 모델
2. __독립된 빌드와 매핑된 서브디렉터리를 가진 단일 소스 저장소__<br/>
>> 명확한 소스 구조를 통해 빌드를 소스 코드의 특저 부분과 쉽게 매핑<br/>
3. __마이크로서비스 당 하나의 코드 저장소와 CI빌드 사용하기__
>> 각 마이크로서비스는 각자의 CI 빌드에 매핑된 각각 소스 코드 저장소를 가져 코드 변경 발생 시, 필요한 필드, 테스트만 수행, 배퐇라 하나의 산출물만 얻음<br/>
---
<br/>

### 빌드 파이프라인과 지속적 배포
빌드 파이프라인 개념은 각 단계를 완료하면서 소프트웨어 과정을 추적하는 훌령한 방법을 제공, 소프트웨어 품질에 대한 통찰력을 가지도록 함<br/>
지속적 배포(continuous delivery / CD)는 모든 체크인의 실환경 준비에 대한 지속적인 피드백을 얻고 나아가 모든 체크인을 빠짐없이 릴리즈 후보로 여기는 접근 방법<br/>
CD에서는 소프트웨어가 진행하는 수동, 자동화의 모든 단계를 모델링하는 다단계 별도 파이프라인의 개념을 환장하여 이것을 수행

> 빌드 파이프라인으로 모델링된 표준 릴리스 프로세스<br/>
> 컴파일&빠른테스트 -> 느린 테스트 -> UAT(사용자 인수 테스트) -> 성능 테스팅 -> 실환경<br/>

> 서비스가 독립적으로 릴리스하기 원하는 마이크로서비스 세계에서는 CI 와 마찬가지로 서비스 당 하나의 파이프라인을 원할 것! <br/>
> 이 파이프라인을 통해 산출물이 생성, 실환경까지 보내진다

1. 그리고 피할 수 없는 예외
'빌드 당 하나의 마이크로서비스' 방법은 전적으로 지향'<br/>
그러나 신규 프로젝트를 막 시작할 때 등 서비스 경계를 확정하는 동안 많은 혼돈을 겪기 쉽기 때문에 도메인에 대해 충분히 이해할 때까지 초창기 서비스를 큰 부분으로 유지하는 것이 좋음<br/>
__모든 서비스를 하나의 번들로 릴리스할 필요가 있게 되더라도, 이는 전적으로 과도기 단계에서만 해당__<br/>
__서비스 API들이 안정화될 때 그들을 각각의 빌드로 분리하기 시작하라!__
---
<br/>

### 플랫폼별 산출물
---
<br/>

### 운영체계 산출물
---
<br/>

### 커스텀 이미지
1. 산출물로서의 이미지
2. 불변 서버
---
<br/>
### 환경
---
<br/>

### 서비스 환경 구성
---
<br/>

### 서비스의 호스트 매핑
1. 호스팅당 다수의 서비스
2. 애플리케이션 컨테이너
3. 호스트당 단일 서비스
4. 서비스로서의 플랫폼
---
<br/>

### 자동화
1. 자동화의 위력에 대한 두 가지 사례 연구
---
<br/>

### 물리 머신엥서 가상회로
1. 전통적 가상화
2. 베이크런트
3. 리눅스 컨터이너
4. 도커
---
<br/>

### 배포 인터페이스
---
<br/>

### 마치며
---
