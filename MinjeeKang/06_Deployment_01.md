배포
===
> 모놀리식 애플리케이션 배포 과정은 단순하지만 <br/>
> 상호 의존성을 가진 마이크로서비스의 배포는 모놀로식과 전혀 다르다.
<br /><br />

### 지속적 통합 (continuous Integration)
모든 사람이 서로 동기를 맞추는 것이 핵심목표 <br />
-> 새롭게 체크인된 코드가 기존 코드와 적절히 통합됨을 보장함으로써 달성<br />
이를위해 CI서버는 코드의 커밋을 감지, 체크아웃, 코드의 컴파일과 테스트 통과를 확인하는 것과 같은 몇가지 검증을 한다
> CI의 혜택<br />
> 1. 코드 품질에 대해 어느 정도 빠른 피드백
> 2. 바이너리 산출물 자동 생성
> 3. 산출물 빌드를 위한 모든 코드를 버전관리 해 필요할 때 언제든 다시 만들 수 있음
> 4. 배출된 산출물 코드 추적
> 5. CI 도구 자체 기능에 따라 코드, 산출물에 대해 어떤 테스트가 수행되었는지 확인 가능
1. 정말로 하고 있는가<br/>
제즈 험블의 3가지 질문 - CI를 정말로 이해하고 있는지 테스트하기 위한...
>> 1. 하루에 한번 메인 브랜치에 체크인 하는가?
>> 2. 변경을 확인할 테스트 집합이 있는가?
>> 3. 빌드가 깨졌을 때 팀이 그 것을 최우선으로 해결하는가?
***
<br/>

### 지속적 통합을 마이크로서비스로 매핑하기
> 마이크로서비스와 지속적 통합을 생각할 때 CI 빌드와 어떻게 개별 마이크로서비스와 매핑할 것인지 생각해야함

1. __모든 마이크로서비스를 위해 단일 저장소와 CI빌드 사용_
>> 소스 코드 저장소에 어떠한 체크인도 빌드를 작동시킬 것, 그 빌드를 통해 모든 마이크로서비스와 연관된 검증 단계 수행 후 다수의 산출물 생성 -> 모두 동일한 빌드로 묶여있음<br />
>> 신경 쓸 저장소가 적을 수록 빌드도 개념적으로 단순, 개발자 관점에서도 직관적<br />
>> 단점 - 한 서비스 내 한 줄 코드 변경 시에도 모든 서비스가 검증, 빌드, 전체 테스트 등 필요 이상의 시간 소요로 순환 시간에 영향 / 어떤 산출물이 배포되고 되지 않아야 하는지 알기 어려움<br />
>> -> 전적으로 피해야할 패턴이나 프로젝트 초기, 특히 한 팀이 모든 작업을 한다면 짧은 기간동안 적잘한 모델
2. __독립된 빌드와 매핑된 서브디렉터리를 가진 단일 소스 저장소__<br/>
>> 명확한 소스 구조를 통해 빌드를 소스 코드의 특저 부분과 쉽게 매핑<br/>
3. __마이크로서비스 당 하나의 코드 저장소와 CI빌드 사용하기__
>> 각 마이크로서비스는 각자의 CI 빌드에 매핑된 각각 소스 코드 저장소를 가져 코드 변경 발생 시, 필요한 필드, 테스트만 수행, 배퐇라 하나의 산출물만 얻음
***
<br/>

### 빌드 파이프라인과 지속적 배포
빌드 파이프라인 개념은 각 단계를 완료하면서 소프트웨어 과정을 추적하는 훌령한 방법을 제공, 소프트웨어 품질에 대한 통찰력을 가지도록 함<br/>
지속적 배포(continuous delivery / CD)는 모든 체크인의 실환경 준비에 대한 지속적인 피드백을 얻고 나아가 모든 체크인을 빠짐없이 릴리즈 후보로 여기는 접근 방법<br/>
CD에서는 소프트웨어가 진행하는 수동, 자동화의 모든 단계를 모델링하는 다단계 별도 파이프라인의 개념을 환장하여 이것을 수행

> 빌드 파이프라인으로 모델링된 표준 릴리스 프로세스<br/>
> 컴파일&빠른테스트 -> 느린 테스트 -> UAT(사용자 인수 테스트) -> 성능 테스팅 -> 실환경<br/>

> 서비스가 독립적으로 릴리스하기 원하는 마이크로서비스 세계에서는 CI 와 마찬가지로 서비스 당 하나의 파이프라인을 원할 것! <br/>
> 이 파이프라인을 통해 산출물이 생성, 실환경까지 보내진다

1. 그리고 피할 수 없는 예외
'빌드 당 하나의 마이크로서비스' 방법은 전적으로 지향'<br/>
그러나 신규 프로젝트를 막 시작할 때 등 서비스 경계를 확정하는 동안 많은 혼돈을 겪기 쉽기 때문에 도메인에 대해 충분히 이해할 때까지 초창기 서비스를 큰 부분으로 유지하는 것이 좋음<br/>
__모든 서비스를 하나의 번들로 릴리스할 필요가 있게 되더라도, 이는 전적으로 과도기 단계에서만 해당__<br/>
__서비스 API들이 안정화될 때 그들을 각각의 빌드로 분리하기 시작하라!__
***
<br/>

### 플랫폼별 산출물
대부분의 기술 스택은 산출물을 생성, 설치파는 도구와 함께 훌륭한 산출물 형태를 가지고 있음
> 루비 gem, 자바 jar file / war file, 파이썬 gee 등

마이크로서비스 관점에서 사용하는 기술 스택에 따라 이 산출물 자체 만으로 부족할 수 있어 산출물을 배포, 실행하기 위해 다른 소프트웨어를 설치, 구성할 방법 필요<br />
(산출물이 특정 기술 스택에 한정, 여러 기술이 혼용될 때 배포가 어려움)
***
<br/>

### 운영체계 산출물
특정 기술에 제한적인 산출물과 관련 문제를 피할 수 있는 방법은...<br />
하부 운영 체계에 네이티브한 산출물을 생성하는 것 <br />
> 예 : 레드햇, CentOS 기반 시스템에서는 RPM, 우분투에서는 deb 패키지, 윈도우에서는 MSI를 빌드

단점<br />
1. 처음 패키지 생성 시, 어려움
2. 다양한 운영체제 배포 시, 다른 운영체제 산출물을 관리하는 작업의 부담
***
<br/>

### 커스텀 이미지
소프트웨어 설치 전 모든 필수 구성 요소 설치까지 기다려야 하기 때문에 시스템이 제로-다운타임을 허용하지 않는다면 실환경 배포 시, 다운타임이 늘어날 수 있음<br />
-> 예) 자바 어플리케이션 실행을 위한 오라클 JVM 설치(약 5분가량 시간 소요)<br />
> 기동시간을 줄이기 위한 방법은 공통적으로 의존하는 것들을 주입한 가상 머신 이미지를 만드는 것<br />
> 예) 소프트웨어 배포를 할 경우 커스텀 이미지의 인스턴스 가동 후 서비스 최신 버전 설치 <br />
> -> 이미지를 한 번만 빌드하기 때문에 이미지의 복제본 연속 실행 시, 그것들을 설치하는 시간이 필요 없음<br /><br />
> 단점<br />
> * 이미지 생성 시간이 오래 소요될 수 있음
> * 생성된 이미지가 클 수 있음

1. 산출물로서의 이미지<br />
서비스를 이미지 안에 구워내고 서비스 산출물이 이미지가 되는 모델 적용<br />
예) 빠른 가동 시간으로 인해 넷플릭스는 자신들의 서비스를 AWS AML로 생성하는 모델 채택
2. 불변 서버<br />
실행 중인 서버에 어떠한 변경도 하지 않고 아주 작은 변경이라도 새로운 머신을 생성하기 위해서는 빌드 파이프라인을 통해야 함
***
<br/>

### 환경
실환경은 두 개의 데이터 센터에서 다수의 부하 분산용 호스트로 구성될 수 있는 반면, <br />
테스트 환경은 하나의 호스트에 의해 운영될 수 있어 이런 환경의 차이는 문제를 야기할 수 있음
***

### 서비스 환경 구성
> 이상적으로 환경 구성은 작아야하며<br/>
> 환경마다 변경해야 하는 제한된 기능이 되고 이는 전적으로 최소화 되어야 함

서비스 환경마다 바뀌워야 하는 환경 구성일 때 배포 프로세스의 일부로 다루는 방법
1. 환경당 하나의 산출물을 빌드하고 환경 구성을 그 산출물에 포함
2. 단일 산출물을 생성, 환경 구성을 분리해서 관리
***
<br/>

### 서비스의 호스트 매핑
1. 호스팅당 다수의 서비스
2. 애플리케이션 컨테이너
3. 호스트당 단일 서비스
4. 서비스로서의 플랫폼
***
<br/>

### 자동화
1. 자동화의 위력에 대한 두 가지 사례 연구
***
<br/>

### 물리 머신엥서 가상회로
1. 전통적 가상화
2. 베이크런트
3. 리눅스 컨터이너
4. 도커
***
<br/>

### 배포 인터페이스
***
<br/>

### 마치며
***
