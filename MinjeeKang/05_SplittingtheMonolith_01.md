# 5장 모놀리스 분해하기 - 첫번째
> 모놀리스는 시간이 프르면서 자라나고, 빠른 속도로 새로운 기능과 코드 라인을 요구하며, 머지 않아 조직 내 사람들이 건드리거나 바꾸기를 두려워하는 거대하고 무서운 존재가 된다. ---> 그러나 올바른 도구를 위해 방어 가능!


### 접합부가 중요하다
우리가 원하는 것 : 응집력 높고 느슨한 결합 서비스<br />
모놀리스의 문제 : 관련 없는 모든 종류의 코드를 가져와 서로 붙여놓아 느슨한 결합이 존재하지 않으며 일부 소스 수정 시, 반드시 전체 시스템 재배포 필요<br />
-> 접합부를 찾아야 함! - 코드베이스 정리 목적이 아닌 서비스 경계가 될 수 있는 접합부
> 경계가 있느 콘텍스트의 정의가 조직 내 응집력 있고 느슨한 결합된 경계를 표한하기 때문에 경계 인식 필요<br />
> 대부분의 프로그래밍 언어는 유사한 코드를 그룹화하는 네임스페이스 개념 제공-> 자바의 package 개념(적절하지 않지만...)


### 뮤직코퍼레이션 분해하기
콘텍스트를 대표하는 패키지 생성> 기존 코드를 패키지로 이동<br />
-> 시간이 지나면서 남아있는 코드와 그렇지 못한 코드를 알아가며 생존한 코드가 경계가 있는 콘텍스트로 인식될 수 있음<br />
경계가 있는 콘텍스트를 대표하는 패키지들은 실세계에서 도메인과 같은 방식으로 상호작용해야 함<br />
> 실제 조직에서는 창고부서, 재무부서 간 의존성은 없지만 창고 패키지의 코드가 재무 패키지에 의존성이 있는 것처럼 뭔가 잘못된 것이 보이면 우리는 이 문제를 파악하고 해결할 수 있다

첫번째 서비스를 분리하기 전에 모든 코드를 도메인에 따라 나눠진 패키지들에 따라 정렬할 필요는 없음


### 모놀리스를 분리하는 이유
> 시스템을 조금씩 깍아내듯 분리하기를 강력히 권고!<br/>
점진적 접근법을 통해 마이크로서비스를 더 잘 배울 수 있으며, 무언가 잘못될 경우 피해를 줄일 수 있음

1. 변경의 속도 - 예: 창고의 접합부를 서비스로 분리한다면 그 접합부는 독립된 자율적 개체가 되어 더욱 신속하게 변경 가능
1. 팀 구조
1. 보안
1. 기술


### 뒤엉킨 의존성
코드가 시스템의 나머지 부분과 어떻게 엉켜있는가? - 가능한 종속성이 낮은 접합부 추출을 원함 <br/>
> 뒤엉킨 모든 의존성의 출처가 대개 데이터베이스라는 점!


### 데이터베이스
> 데이터베이스에서 접합부를 찾아야 깔끔하게 분리할 수 있지만 데이터베이스는 길들이기 매우 어려운 야수라니...


### 문제에 대처하기
> 코드 자체를 살펴보고, 데이터베이스에 읽고 쓰는 코드 부분을 보는 것

특정 콘텍스트의 코드 내 데이터베이스 매핑코드 매치 -> 어떤 코드가 데이터베이스의 어떤 부분을 사용하는지 이해<br />
-> 테이블 관계를 그래픽으로 표현하는 것이 가능한 스키마스파이 같은 도구 사용 추천( http://schemaspy.sourceforge.net )


### 예: 외부 키 관계 깨뜨리기
제품목록 코드는 앨범 정보 저장을 위해 일반적인 행 항목 테이블 사용 <br/>
재무 코드는 금융 거래를 기록하기 위해 원장 테이블 사용 <br/>
-> 연말보고서에 특정 앨범을 몇 장 판매해서 얼마의 수익을 냈는지 유용한 정보를 원함<br/>
이를 위해 재무패키지 보고서 코드는 앨범 제목을 가져오도록 행 항목 테이블에 접근 -> 원장 테이블에서 행 항목 테이블에 대한 외부 키 제약 발생
> 해결 <br/> 
재무코드가 행 항목 테이블에 접근하는 방법보다 <br /> 
**재무 코드가 호출할 수 있는 제품 목력 패키지의 API를 통해 데이터를 노출**<br />
이는 추후에 네트워크를 통한 호출의 전신이 될 것


### 예: 공유 정적 데이터
뮤직 쇼핑몰의 모든 서비스가 동일 테이블을 참조
> 해결 <br/>
> 1. 참조 테이블을 각 패키지에 복제
> 1. 공유 정적 데이터를 코드로 다루기
> 1. 정적 데이터를 특정 독립적인 서비스 안에 삽입


### 예: 공유 데이터
고객 기록 테이블 -> 재무 및 창고 코드는 동일한 테이블을 읽고 쓰게 됨 -> 분리 필요
> 해결 <br/>
추상화된 고객 개념 생성<br/>
임시 단계로 Customer로 명명된 새로운 패키지 생성 및 Customer 다른 패키지에 노출시키기 위해 API 사용 가능


### 예: 공유 테이블
제품목록은 판매 음반의 이름 및 가격 저장, 창고는 재고 음반 목록 유지 -> 일반적인 행 항목 테이블의 동일한 장소에 저장
> 해결 <br />
테이블 분리 필요<br/>
창고 -> 재고목록 테이블 / 제품 목록 세부 정보 -> 제품 목록 항목 테이블 생성


### 데이터베이스 리팩토링
1. 단계적인 분리
이제까지 경계가 있는 콘텍스트 주의의 코드를 묶어 애플리케이션 코드에서 접합부를 찾음 <br />
-> 이후에는 애플리케이션 코드를 완전히 분리, 각각의 마이크로서비스를 만들기 전에 <br />
**서비스는 이전과 같이 하나로 유지한 채 우선 스키마 분리를 추천**

> 애플리케이션 코드를 그대로 유지하고 스키마만 분리하면 <br/>
변경한 것으 ㄹ되돌리거나 서비스의 소비자에게 영향을 주지 않고 작은 변경을 계속 할 수 있음
