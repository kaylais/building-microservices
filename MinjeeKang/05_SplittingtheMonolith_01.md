# 5장 모놀리스 분해하기 - 첫번째
> 모놀리스는 시간이 프르면서 자라나고, 빠른 속도로 새로운 기능과 코드 라인을 요구하며, 머지 않아 조직 내 사람들이 건드리거나 바꾸기를 두려워하는 거대하고 무서운 존재가 된다. ---> 그러나 올바른 도구를 위해 방어 가능!

### 접합부가 중요하다
우리가 원하는 것 : 응집력 높고 느슨한 결합 서비스<br />
모놀리스의 문제 : 관련 없는 모든 종류의 코드를 가져와 서로 붙여놓아 느슨한 결합이 존재하지 않으며 일부 소스 수정 시, 반드시 전체 시스템 재배포 필요<br />
-> 접합부를 찾아야 함! - 코드베이스 정리 목적이 아닌 서비스 경계가 될 수 있는 접합부
> 경계가 있느 콘텍스트의 정의가 조직 내 응집력 있고 느슨한 결합된 경계를 표한하기 때문에 경계 인식 필요<br />
> 대부분의 프로그래밍 언어는 유사한 코드를 그룹화하는 네임스페이스 개념 제공-> 자바의 package 개념(적절하지 않지만...)

### 뮤직코퍼레이션 분해하기
콘텍스트를 대표하는 패키지 생성> 기존 코드를 패키지로 이동<br />
-> 시간이 지나면서 남아있는 코드와 그렇지 못한 코드를 알아가며 생존한 코드가 경계가 있는 콘텍스트로 인식될 수 있음<br />
경계가 있는 콘텍스트를 대표하는 패키지들은 실세계에서 도메인과 같은 방식으로 상호작용해야 함<br />
> 실제 조직에서는 창고부서, 재무부서 간 의존성은 없지만 창고 패키지의 코드가 재무 패키지에 의존성이 있는 것처럼 뭔가 잘못된 것이 보이면 우리는 이 문제를 파악하고 해결할 수 있다

첫번째 서비스를 분리하기 전에 모든 코드를 도메인에 따라 나눠진 패키지들에 따라 정렬할 필요는 없음

### 모놀리스를 분리하는 이유
> 시스템을 조금씩 깍아내듯 분리하기를 강력히 권고!<br/>
점진적 접근법을 통해 마이크로서비스를 더 잘 배울 수 있으며, 무언가 잘못될 경우 피해를 줄일 수 있음

1. 변경의 속도 - 예: 창고의 접합부를 서비스로 분리한다면 그 접합부는 독립된 자율적 개체가 되어 더욱 신속하게 변경 가능
1. 팀 구조
1. 보안
1. 기술

### 뒤엉킨 의존성
코드가 시스템의 나머지 부분과 어떻게 엉켜있는가? - 가능한 종속성이 낮은 접합부 추출을 원함 <br/>
> 뒤엉킨 모든 의존성의 출처가 대개 데이터베이스라는 점!


### 데이터베이스
> 

### 문제에 대처하기

### 예: 외부 키 관계 깨뜨리기

### 예: 공유 정적 데이터

### 예: 공유 데이터

### 예: 공유 테이블

### 데이터베이스 리팩토링
1. 단계적인 분리
