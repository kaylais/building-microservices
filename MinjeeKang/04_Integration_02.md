# 4장 통합 - 두번째
> 

### 상태 기계로서의 서비스
> 고객 마이크로서비스는 고개의 모든 행동양식과 관련된 로직 소유 <br />
> 핵심 도메인 개념의 수명주기를 이처럼 명확히 모델링 하는 것은 효과적

### 반응형 확장
> 다수의 호출결과를 조합하고 결과에 따라 연산을 실행하는 매커니즘

더 많은 서비스를 호출하게 될 때, 특히 하나의 작업을 수행하기 위해 다수의 호출이 필요할 때 선택한 기술 스택으로 반응형 확장을 고려할 것 -> 단순해짐

### 마이크로서비스 세계에서 코드 재사용의 위험성과  DRY
> DRY는 중복 코드를 회피하는 시도로 단순하게 정의되지만 더 명확하게 시스템의 행동양식, 지식의 중복을 회피하는 모든 시도<br />
> 반드시 피해야 할 위험 중 하나는 마이크로서비스와 소비자 간 지나친 결합이며 이는 마이크로서비스 자체의 작은 변경 사항 하나가 많은 소비자에게 불필요한 변경을 초래
> 공유 코드 서비스 경계를 넘어서 사용하면 잠재적 결합의 문제를 안고 있게 되나 로깅 라이브러리와 같은 공통 코드는 외부에서 보이지 않는 부의 개념이므로 사용해도 문제 없음

1. 클라이언트 라이브러리<br />
클라이언트 라이브러리가 서비스를 쉽게 사용하고 서비스 소비에 필요한 중복코드를 줄인다는 주장<br />
그러나!!! 사람들이 코드 중복을 회피하는 용도로만 인식되는 것을 우려!!<br />
예를 들어 넷플릭스에서 사용되는 클라이언트 라이브러리는 시스템의 신뢰성과 확장성을 보장하려는 것!

### 참조에 의한 접근
마이크로서비스가 Customer 와 같은 핵심 도메인 개체의 수명주기를 포함한다고 봐야함 -> 결과적으로 고객 서비스를 Customer 개체들의 참값의 근원으로 고려<br />
> 이벤트 발생 자체 뿐 아니라 무슨일이 일어나는지도 알아야 함<br />
-> 예: Customer 자원 변경에 따른 업데이트를 받고 있다면 이벤트가 Customer가 어떤 상태였는지 아는 것이 중요<br />
-> 개체에 대한 참조를 유지한다면 개체의 현재 상태를 알 수 있음

### 버전관리
1. 가능하면 지연하기<br />
> 서비스와 처음부터 너무 강하게 결합되지 않도록 하는 것이 호환성 깨뜨리는 변경을 늦추는 방법 <br />
> 관심없는 데이터의 변경을 무시할 수 있도록 독자(reader)를 구현하는 것 -> 마틴파울러/ 관대한 독자(Tolerant Reader)<br />
> 전송할 때는 보수적으로 받아드릴 때는 자유롭게 - 포스텔의 법칙
2. 호환성을 깨뜨리는 변경 일찍 찾아내기<br />
> 소비자를 일찍 고장내는?? 변경은 최대한 빠르게 발견하는 것이 중요<br />
> 다양한 클라이언트 라이브러리를 지원한다면 각 라이브러리를 이용, 최신 서비스를 지원하는 테스트 수행도 도움되는 방법
3. 유의적 버전 관리<br />
> 클라이언트가 서비스 버전 번호 만으로 해당 서비스와 통합가능한지 알 수 있는 것!(MAJOR, MINOR, PATCH)<br />
> MAJOR 버전 번호 증가는 하위 호한성이 깨진 변경을 발생했음을 의미<br />
> MINOR 버전 번호 증가는 하위 호환성을 유지, 새로운 기능들이 추가되었음을 의미<br />
> PATCH 버전 번호 증가는 기존 기능 버그 수정 의미<br />
4. 다른 엔드포인트와 공존<br />
> 마이크로서비스가 독립적으로 릴리즈하는 능력을 항상 유지하기를 바라기 떄문에 소비자에게 우리와 보조를 맞춰 업그레이드 하도록 강요하는 일은 피하고자 함<br />
> 사실성 확장-수축 패턴 :  호환성을 깨뜨리는 변경을 단계적으로 적용하게 해줌, 어떤 작업을 수행하는 구식, 신식 방법 모두 지원, 우리가 제공하는 기능 확장- 구 소비자들이 신식 방법을 따른다면 이전 기능을 제거하고 API를 축소<br />
5. 다수의 병행 서비스 버전 사용하기<br />
> 다양한 버전의 서비스를 동시 실행, 구 소비자의 트래픽을 구 버전에 신규 소비자를 신버전에 라우팅하는 것<br />
> 이 버전을 잘 사용하지 않는 이유<br />
> 1) 한 서비스의 내부 버그를 고치려면 두 벌의 서로 다른 서비스를 수정/배포 필요<br />
> 2) 소비자가 찾는 서비스로 유도하기 위한 부가적 로직 필요<br />
> 3) 서비스가 처리해야 할 영속적 상태가 있는지 고려
   
### 사용자 인터페이스
1. 디지털을 향해<br />
> 최근 웹과 모바일을 다르게 다뤄야 한다는 고정관념에서 벗어나기 시작<br />
2. 제약<br />
> 사용자가 시스템과 상호작용을 하는 또 다른 형태 - 브라우저 종류, 해상도 등의 제약 등<br />
> 주요 제품인 핵심 서비스들이 동일하더라도 각 인터페이스의 다양한 제약에 따라 그 서비스들을 적절히 적용할 방법 필요<br />
3. API 구성<br />
> HTTP 상에서 XML, JSON 으로 서로 통신하고 사용자 인터페이스가 직접 API와 통신하는 것이라 가정<br />
> -> 다양한 종류의 디바이스에 맞춤화된 응답능력 없음 / 서비스에 직접적으로 수많은 호출을 하는 것은 모바일 기기에 부담<br />
> -> 다수 하부호출을 모아 외부로 호출할 수 있는 API게이트웨이를 사용하면 도움됨!<br />
4. UI 부분 구성<br />
> 서비스들이 UI 생성에 필요한 일부 UI를 직접 제공 -> 일련의 큰 단위의 UI 부분들을 조립할 떄 아주 효과적일 수 있음<br />
> 이점 : 서비스르 변경하는 팀이 해당 서비스의 UI 부분도 담당할 수 있음<br />
> 문제 : 사용자 경험의 일관성 유지 / UI컴포넌트 제공할 수 없는 네이티브 애플리케이션, 무거운 크라이언트에서는??<br />
5. 프론트엔드를 위한 백엔드<br />
> 백엔드 서비스와의 호출이 많은 인터페이스 문제나 각종 디바이스별 콘텐트의 맞춤화 요구에 일반적인 해결책 -> 서버 측 엔드포인트 또는 API 게이트웨이를 제공<br />
> 모든서비스에대한거대한 단일계층이 될 수 있기 때문에 백엔드를 특정 사용자 인터페이스 또는 애플리케이션을 제한 필요 ( 프론트엔드를 위한 백엔드)<br />
> 프론트엔드를 위한 백엔드(BFF) 패턴에서는  특정 UI에 집중하는 팀이 해당 서버 컴포넌트 담당<br />
> 문제 - 집합계층의 위험성과 유사<br />
> -> 백엔드가 사용하는 다양한 기능의 비즈니스 로직은 서비스에 존재, BFF 는 특정 사용자 경험을 제공하기 위한 행동양식에만 포함<br />
6. 하이브리드 방식<br />
> 사용자들에게 제공하는 하부 기능들의 응집력을 유지

### 외부 소프트웨어와 통합
1. 통재 부족<br />
2. 맞춤화<br />
3. 스파게티 통합<br />
4. 여러분 방식대로<br />
5. 교살자 패턴<br />

### 정리





- - -

