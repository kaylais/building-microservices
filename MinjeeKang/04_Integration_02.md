# 4장 통합 - 두번째
> 

### 상태 기계로서의 서비스
> 고객 마이크로서비스는 고개의 모든 행동양식과 관련된 로직 소유 <br />
> 핵심 도메인 개념의 수명주기를 이처럼 명확히 모델링 하는 것은 효과적

### 반응형 확장
> 다수의 호출결과를 조합하고 결과에 따라 연산을 실행하는 매커니즘

더 많은 서비스를 호출하게 될 때, 특히 하나의 작업을 수행하기 위해 다수의 호출이 필요할 때 선택한 기술 스택으로 반응형 확장을 고려할 것 -> 단순해짐

### 마이크로서비스 세계에서 코드 재사용의 위험성과  DRY
> DRY는 중복 코드를 회피하는 시도로 단순하게 정의되지만 더 명확하게 시스템의 행동양식, 지식의 중복을 회피하는 모든 시도<br />
> 반드시 피해야 할 위험 중 하나는 마이크로서비스와 소비자 간 지나친 결합이며 이는 마이크로서비스 자체의 작은 변경 사항 하나가 많은 소비자에게 불필요한 변경을 초래
> 공유 코드 서비스 경계를 넘어서 사용하면 잠재적 결합의 문제를 안고 있게 되나 로깅 라이브러리와 같은 공통 코드는 외부에서 보이지 않는 부의 개념이므로 사용해도 문제 없음

1. 클라이언트 라이브러리<br />
클라이언트 라이브러리가 서비스를 쉽게 사용하고 서비스 소비에 필요한 중복코드를 줄인다는 주장<br />
그러나!!! 사람들이 코드 중복을 회피하는 용도로만 인식되는 것을 우려!!<br />
예를 들어 넷플릭스에서 사용되는 클라이언트 라이브러리는 시스템의 신뢰성과 확장성을 보장하려는 것!

### 참조에 의한 접근
마이크로서비스가 Customer 와 같은 핵심 도메인 개체의 수명주기를 포함한다고 봐야함 -> 결과적으로 고객 서비스를 Customer 개체들의 참값의 근원으로 고려<br />
> 이벤트 발생 자체 뿐 아니라 무슨일이 일어나는지도 알아야 함<br />
-> 예: Customer 자원 변경에 따른 업데이트를 받고 있다면 이벤트가 Customer가 어떤 상태였는지 아는 것이 중요<br />
-> 개체에 대한 참조를 유지한다면 개체의 현재 상태를 알 수 있음

### 버전관리
1. 가능하면 지연하기
2. 호환성을 깨뜨리는 변경 일찍 찾아내기
3. 유의적 버전 관리
4. 다른 엔드포인트와 공종
5. 다수의 병행 서비스 버전 사용하기
   
### 사용자 인터페이스
1. 디지털을 향해
2. 제약
3. API 구성
4. UI 부분 구성
5. 프론트엔드를 위한 백엔디
6. 하이브리드 방식

### 외부 소프트웨어와 통합
1. 통재 부족
2. 맞춤화
3. 스파게티 통ㄹ합
4. 여러분 방식대로
5. 교살자 패턴

### 정리





- - -

