# CHAPTER 8. Monitoring
> 모놀리식 애플리케이션의 경우에는 단일 장애 지점이 있어 장애 분석이 다소 쉽다. 하지만 마이크로서비스 기반 시스템의 경우에는 모니터링에 있어 더 복잡한 문제가 존재한다.

## 단일 서비스, 단일 서버
- 로그 : 로그인 후 로그를 스캔하기 위해 명령행 도구를 사용하여 그 정보를 얻을 수 있다. 게다가 오래된 로그가 디스크 공간을 다 채우지 않도록 logratate를 사용할 수 있다. 
- 응답시간 추적 : 서비스 앞단에 위치한 웹 서버의 로그나 서비스 자체의 로그를 관찰하면서 추적할 수 있다.

## 단일 서비스, 다수 서버
- 실행되는 서비스의 복제본들이 분리된 호스트 상에 있다면 요청은 부하 분산기를 통해 다른 서비스 인스턴스로 전달된다. 
- 로그 : 여러 호스트에 동일하 명령 실행이 가능한 SSH 멀티플랙서와 같은 도구를 사용할 수 있다. 
- 응답시간 추적 : 부하 분산기에서 추적해서 쉽게 취합할 수 있다. 하지만 부하 분산기의 오동작도 문제가 될 수 있으므로 분산기도 추적 대상이 되어야한다. 

## 다수 서비스, 다수 서버
- 로그부터 애플리케이션 측정지표까지 가능한 많은 수집과 집중식 취합을 해야한다.

## 로그, 로그 , 더 많은 로그…
- 로그를 수집하고 중앙에서 접근하기 위해 전문적인 서브시스템을 이용해야한다. 대표적인 예는 많은 로그 파일 모팻을 파싱하고 추가 분석을 위해 하부 시스템에 전송할 수 있는 로그스태쉬다. 

## 다수 서비스 간의 측정지표 추적
- 다른 호스트의 로그를 살펴보는 것은 어렵기 때문에 측정지표를 수집하고 보기 위한 더 나은 방법을 검토해야 하다. 명확한 패턴이 드러나도록 오랜 기간을 걸쳐 시스템의 행동 방식에 대한 측정지표를 수집해야 한다.
- 복잡한 환경에서는 서비스들의 인스터스가 매우 빈번히 프로비저닝되기 때문에 우리가 선택한 시스템이 새로운 호스트로부터 측정지표를 매우 쉽게 수집하기 원한다. 
- 그래파이드(Graphite)느 아주 단순한 API를 제공해서 실시간으로 측정지표를 전송할 수 있고 현재 상황을 보여주는 차트나 다른 형태의 디스플레이를 생성하기 위해 그 측정지표에 대한 질의도 할 수 있다. 볼륨이 지나치게 커지지 않도록 오래된 측정지표의 해상도를 낮춰 효과적인 구성이 가능하다.
- 그래파이트는 여러 표본을 취합하고 한 표본에 따라 자세히 검색함으로써 전체 시스템 서비스 그룹 또는 단일 인스턴스에 대한 응답시간을 알 수 있다. 
- 측정지표의 추이를 이해하는 또 다른 혜택은 용량 계획이다. 트렌드의 추적과 렌드에 따른 할 일에 대해 더 잘 알게 될수록 시스템의 비용 효율성과 응답성도 높아진다.

## 서비스 측정지표
- 웹 서비스라면 최소한 기본으로 응답시간과 에러율 같은 측정지표를 노출해야한다. 
- 서비스가 측정지표를 표준 시스템에 전송하는 것을 도와주는 라이브러리들이 다양한 플랫폼에서 동작한다.
- 코다헤일의 측정지표 라이브러리(http://mertics.odahale.com)는 JVM용 라이브러리의 한 예로 측정지표를 카운터, 타이머 또는 측정기로 저장하게 해준다. 

## 합성 모니터링
- 시스템이 유의미하게 (semantically) 동작하고 있음을 보장하기 위해 합성된 트랜잭션(synthetic transaction)을 사용할 수 있다. 이 기법은 종종 유의적 모니터링(semantic monitoring)으로 불린다.
- 유의적 모니터링으로 문제를 리포트할 때는 상세한 이유가 필요하므로 합성 트랜잭션이 저수준의 측정지표를 대페한 것은 아니다. 
- 유의적 모니터링 구현하기
    - 시스템은 테스트 실행과 결과확인에 필요한 수단을 이미 제공하고 있다 테스트의 일부 집합을 시스템을 지속적으로 모니터링하는 방법으로 사용한다.
    - 테스트의 데이터 요구 사항에 대해 주의해야한다. 실제 데이터가 시간이 지나며 바뀐다면 이 테스트를 다양한 데이터에 적용할 방법을 찾거나 다른 데이터 소스를 사용할 수 있다.
    - 예측하지 못한 부작용을 우발적으로 만들지 않도록 보장해야 한다. 

## 상관관계 ID
- 다수 서비스 간의 호출 체인을 추적하기 위한 유용한 방법 중 하나는 상관관계 ID (correlation ID)를 이용하는 것이다. 첫 호출이 이뤄질 때 호출에 대한 전역 호출 식별자 (GUID : globally unique idntifier)를 생성하고 후속하는 모든 호출에 전달한다. 그릭 로그 레벨이나 날짜와 같은 구성 요소와 함께 구조화된 방식으로 로그를 넣을 수 있다. 이제 올바른 로그 집계 도구를 통해 시스템에서 일관되게 추적할 수 있을 것이다.
- 상간관계 ID의 전달을 이해하기 위해서는 표준화가 필요하고 시스템 경계를 넘어 더 강력히 시행되어야 한다. 이렇게 만들어진 도구는 호출의 전체 연결 단계를 파악할 수 있으므로 이벤트 폭풍(event storm)과 코너 케이스(corner case)를 추적하거나 심지어 비정상적인 고비용 트랜잭션을 확인하는 데 이용할 수 있다.
- 일관된 상관관계 ID 전달은 공유 씬 클라이언트 래퍼 라이브러리를 사용하는 중요한 근거가 된다. 특정 규모로 커지면 모두가 하위 서비스를 올바른 방식으로 호출하고 올바른 종류의 데이터 수집을 보장하기 어려워진다. 호출 체인에서 한 서비스라도 이 ID를 누락한다면 중요한 정보를 잃게 된다. 처음부터 상관관계 ID를 지원하는 자체 클라이언트 라이브러리를 만들기로 결정한다면 그 라이브러리를 매우 가볍게 유지하고 특정 생산자 서비스와 결합되지 않도록 해야한다.

## 전파 
- 전파 장애(cascading failure)는 특히 위협적이다. 그러므로 시스템 간의 통합 지점을 모니터링하는 것이 중요하다. 각 서비스 인스턴스는 데이터베이스부터 협업하는 다른 서비스에 이르기까지 하위 의존성 상태를 추적하고 노출해야 한다. 또한 이러한 정리된 현황을 알 수 있도록 수집된 정보들을 취합해야 한다. 
- JVM상에서 실행되는 히스트릭스 (지연시간 및 장애 내성 로직을 추가하여 분산 환경 서비스들 간의 상호작용을 통제하는 라이브러리)와 같은 몇몇 라이브러리는 이러한 모니터링 기능을 훌륭히 제공한다.

## 표준화
- 모니터링은 표준화가 엄청나게 중요한 분야다. 많은 인터페이스를 이용하는 사용자에게 기능을 제공하기 위해 다양한 방식으로 협업하는 서비스들이 있다면 총체적인 방식으로 시스템을 바라볼 수 있어야 한다.

## 관련 고려하기
- 수집하는 모든 데이터는 목적이 있다. 따라서 데이터를 살펴보려는 사람들의 유형에 따라 다음 사항을 고려해야 한다.
    - 어떤 것을 당장 알아야 하는가?
    - 어떤 것을 나중에 알아도 되는가?
    - 어떻게 데이터를 소비하고 싶은가?
- 나중에 확인이 필요한 데이터에 쉽게 접근할 수 있게 하고 어떻게 이 데이터를 소비할 것인지 논의할 시간을 가져야 한다.

## 앞으로
- 이벤트를 취합하고 저장하는 데 사용되는 시스템들을 통합하고 리포팅하도록 만들 수 있다면 더 단순한 아키텍처를 구축할 수 있게 된다. 
- 다양한 유형의 측정지표를 위한 특수한 도구 체인을 사용하지 않고 상당한 규모가 지원 가능한 보다 일반적인 이벤트 라우팅 시스템으로 이동하고 있다. 이러한 시스템은 훨씬 더 많은 유연성을 제공하는 동시에 실제로 아키텍처를 단순화한다.

