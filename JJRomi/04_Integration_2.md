## 상태 기계로서의 서비스
- 고객 마이크로 서비스는 고객의 모든 행동양식과 관련된 로직을 소유한다.
- 고객  정보 변경에 관한 결정이 고객 서비스 외부에서 이뤄진다면 응집력을 잃은 것이다.
- 핵심 도메인 개념의 생명주기를 이처럼 명확히 모델링하는 것은 매우 효과적이다.

## 반응형 확장 (Rx : reactive extension)
- 다수의 호출 결과를 조합하고 그 결과에 따라 연산을 실행하는 메커니즘이다.
- 이들 호출은 그 자체로 블로킹 (blocking) 또는 논블로킹(nonblocking)호출이 될 수 있다.
- 하위 서비스에 대해 동시에 발생하는 호출들을 훨씬 쉽게 처리하면서 다수의 호풀을 함께 조합할 수 있다.

## DRY( Don’t Repeat Yourself) 
- 중복된 코드를 회피하는 시도로 단순하게 정의되지만, 더 명확하게 시스템의 행동양식과 지식의 중복을 회피하는 모든 시도라고 할 수 있다.
- 공유 코드의 사용이 마이크로서비스와 소비자 간의 지나친 결합을 만들 수 있다.
- 공유 코드를 서비스 경계를 넘어서 사용한다면 잠재적인 결합의 문제를 안고 있는 셈이다.
- 코드를 공유하기보다는 결합이 생기지 않도록 그 템플릿을 새로운 서비스마다 복사한다.


## 클라이언트 라이브러리
- 클라이언트 라이브러리에 더 많은 로직이 스며들수록 응집력이 더 많이 무너진다.
- 클라이언트 라이브러리의 업데이트 시점을 클라이언트가 담당하게 해야한다.
- 각 서비스를 항상 독립적으로 릴리스할 능역을 유지해야하기 때문이다.

## 첨조에 의한 접근
- 고객 서비스로부터 특정 customer 자원을 추출할 경우 어떤 때는 메모리로도 충분하겠지만, 당시 도메인 개체의 내용이 담긴 메모리를 전달하는 결정과 관계없이 자원의 새로운 상태를 확보할 수 있도록 원본 자원의 참조도 포함하라.


## 버전 관리
- 호환성을 깨뜨리는 변경의 영향을 줄이는 가장 좋은 방법은 애초에 결함을 만들지 않는 것이다. 
- 호환성을 깨트리는 변경을 늦추는 다른 방법은 클라이언트에 좋은 행동을 장려하고 서비스와 처음부터 너무 강하게 결합되지 않도록 하는 것이다.
- 서비스를 가능한 한 유연하게 소비하는 클라이언트를 만들려는 사례는 ’전송할 때는 보수적으로, 받아들일 때는 자유롭게’ 라는 포스텔의 법칙(견고성의 원칙)을 입증한다.
- 다양한 클라이언트 라이브러리를 지원한다면 각 라이브러리를 이용해서 최신 서비스를 지원하는 테스트를 수행하는 것도 도움이 되는 또 다른 방법이다.

## 유의적 버전 관리 (semantic versioning)
- 클라이언트가 서비스의 버전 번호만 보고도 해당 서비스와 통합 가능한지 알 수 있는 것이다.
- 각 버전은 MAJOR, MINOR, PATCH 형태이다.
- MAJOR : 버전 번호의 증가는 하위 호환성이 깨진 변경이 발생했음을 의미한다.
- MINOR : 버전 번호의 증가는 하위 호환성을 유지하면서 새로운 기능들이 추가되었음을 의미한다.
- PATCH : 버전 번호의 증가는 기존 기능의 버그를 수정했다는 것을 의미한다.

## 다른 엔드포인트와 공존
- 확장-수축 패턴의 한 예로, 호환성을 깨뜨리는 변경을 단계적으로 적용하게 해준다. 어떤 작업을 수행하는 구식과 신식 방법을 모두 지원하면서 우리가 제공하는 기능을 확장한다. 구 소비자들이 신식 방법을 따른다면 이전 기능을 제거하고 API를 축소한다.
- 단일 엔포인트만 지원됨 -> 새 릴리즈가 배포되고 새로운 엔드포인트가 추가됨 -> 구버전 엔드포인트가 더 이상 쓰이지 않으면 서비스의 신규 릴리스에서 삭제 가능

## 다수의 병행 서비스 버전 사용하기
- 다양한 버전의 서비스를 동시에 실행하고 구소비자의 트래픽을 구버전에, 신규 소비자를 신버전에 라우팅하는 것이다.
- 한 서비스의 내부 버그를 고치려면 두 벌의 서로 다른 서비스를 수정하고 배포해야한다.
- 소비자가 찾는 서비스로 유도하기 위한 부가적인 로직이 필요하다.
- 그 서비스가 처리해야 할 영속적 (저장할) 상태가 있는지 고려해야 한다.

## 사용자 인터페이스
- 사용자 인터페이스란 고객을 이해시키기 위해 모든 마이크로서비스가 함께 협력하는 곳이다.

## 제약(Constraint)
- 사용자가 시스템과 상호작용하는 또 다른 형태다.
- 우리의 주요 제품인 핵심 서비스들이 동일하더라도 각 인터페이스의 다양한 제약에 따라 그 서비스들을 적절히 적용할 방법이 필요하다. 

## UI 부분 구성
- 작은 위젯을 생성하기보다는 무거운 클라이언트 애플리케이션의 전체 구획이나 웹사이트의 페이지 집합을 구성하는 것이다.
- 큰 단위 UI부분은 서버 측 애플리케이션으로부터 제공되며 적절한 API 호출을 수행한다.
- 이러한 UI부분들을 한 곳에 구성할 수 있는 조립 계층이 필요하다. 
- 조립 계층은 서버 측 템플릿처럼 단순하거나 다른 애플리케이션으로 전달되는 페이지들의 집합이 될 수 있다. 

## 프로트엔드를 위한 백엔드 (BFF : Backend For Frontend)
- 특정 UI 에 집중하는 팀이 해당 서버 측 컴포넌트도 담당한다.
- 이 방법의 위험성은 집합 계층의 위험성과 유사하다. 따라서, 백엔드가 사용하는 다양한 기능의 비즈니스 로직은 서비스에 존재해야하고 BFF는 특정 사용자 경험을 제공하기 위한 행동양식만 포함한다.

## 외부 소프트웨어와 통합 
> 상용제품 또는 오픈 소스와 같은 외부 소프트웨어 제품을 사용하는 것을 불가피하다.
- 통제 부족 : 상용제품의 기능을 통합하고 확장하는 일과 관련된 한 가지 난제는 수많은 기술적 결정을 벤더(소프트웨어 판매사)가 결정한다. 이는 통제권을 외부 업체에 양도하는 셈이다. 이때 요령은 통합과 맟춤화를 여러분 방식안으로 끌어들이는 것이다.
- 맞춤화 (cutomization) : 흔히 접근할 수 있는 도구 체인의 특성상 맞춤화의 비용은 처음부터 맞춤 개발을 한 것보다 더 비쌀 수 있음을 주의해야한다.
- 스파게티 통합 
- 여러분 방식대로
    - 서비스로서의 CMS 
    - 다기능 CRM 시스템 : 하부 CRM을 감추기위해 파사드 서비스 사용
- 교살자 패턴 : 교살자를 통해 구버전 시스템에 대한 호출을 잡아내 가로챈다. 교살자는 이 호출을 기존의 레거시 코드 또는 여러분이 작성한 새로운 코드로 바로 경유할지 결정할 수 있다. 그리고 엄청난 분량의 코드 재작성 없이도 한번에 기능을 교체하게 해준다.

