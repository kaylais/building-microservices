# CHAPTER 6. Deployment

## 지속적 통합 (Continuous Intergration)
- 핵심 목표는 모든 사람이 서로 동기를 맞추는 것이며, 그것은 새롭게 체크입된 코드가 기존 코드와 적절히 통합됨을 보장함으로써 달성할 수 있다.
- CI를 통해 코드 품질에 대해 어느 정도 빠른 피드백을 얻을 수 있고 바이너리 산출물을 자동으로 생성할 수 있다.
- 산풀물의 빌드를 위한 모든 코드는 버전 관리가 되므로 필요할 때 언제든지 다시 만들 수 있다.
- 배포된 산출물의 코드를 찾을 수 있는 정도로 추적할 수 있으며, CI 도구 자체의 기능에 따라 코드와 산출물에 대해 어떤 테스트가 수행되었는지 확인할 수 있다.
- CI 사용 여부 확인 질문
  - 하루에 한번 메인 브랜치에 체크인하는가?
    - 자신의 코드는 물론 다른 사람들이 변경한 코드 또한 자주 확인하지 않는다면 향후 통합이 더 어려워진다.
    - 변경을 위해 단기 브랜치를 사용하고 있더라도 가능 한 자주 메인 브랜치에 통합하라.
  - 변경을 확인할 테스트 집합이 있는가?
    - 코드가 기대한 대로 동작하는지 검증하지 않는 CI는 CI가 아니다.
  - 빌드가 깨졌을 때 팀이 그것을 최우선으로 해결하는가?
    - 빌드 문제의 해결과 관련 없는 추가적인 체크인을 중단해야 한다. 변경이 많이 적체되면 그 빌드를 해결할 시간이 급격하게 늘어난다. 결국 빌드를 통과하는 데 엄청난 노력이 들게 된다.

## 지속적 통합을 마이크로서비스로 매핑하기
1) 모든 마이크로서비스를 위해 단일 저장소와 CI빌드 사용하기 (모든 것을 통으로 엮는 것이다.)
  - 표면상으로 다른 방법보다 훨씬 단순해보인다. 
  - 많은 서비스를 한번에 배포하는 것이 괜찮은 곳에 락스템 릴리스**의 개념에 적용하면 이 모델은 완벽하게 잘 작동한다.
  - 프로젝트 초기에 한 팀이 모든 작업을 한다면 짧은 기간 동안에는 적절할 수 있다.
  - 한 서비스에서 한 줄의 코드를 바꾸더라도 모든 서비스가 점증되고 빌드된다는 중대한 단점이 있다.
  - 하나의 변경을 개발에서 실운영환경에 전달하는 속도 즉, 순환 시간에 영향을 준다.
2) 독립된 빌드와 매핑된 서브디렉터리를 가진 단일 소스 저장소 사용하기 ( 모든 코드를 포함하는 단일 소스 틔를 두고 다수의 CI 빌드가 소스 트리의 부분들과 매핑하도록 하는 것이다.)
- 명확한 소스 구조를 통해 빌드를 소스 코드의 특정 부분과 쉽게 매핑할 수 있다.
- 신경 쓸 저장소가 하나뿐이므로 체크인/체크아웃 과정이 단순해진다.
- 한번에 여러 서비스의 소스코드에 체크인하는 습관이 들기 쉽다. 이 습관이 서비스가 같은 식으로 서로 결합되는 변경을 만들 가능성이 높다.
3)마이크로서비스당 하나의 코드 저장소와 CI빌드 사용하기
- 각 마이크로서비스는 각자의 CI빌드에 매핑된 각각의 소스 코드 저장소를 가진다. 
- 코드 변경이 발생하면 필요한 빌드와 테스트만 수행하고 배포할 하나의 산출물만 얻는다.
- 서비스의 소유는 저장소와 빌드도 책임지는 것을 의미한다.

## 빌드 파이프라인
- 빌드 파이프라인을 생성하여 빌드 내에 여러 다른 단계를 두어 한 단계에는 빠른 테스트를, 다른 단계에는 느린 테스트를 설정한다.
- 각 단계를 완료하면서 소프트웨어 과정을 추적하는 훌륭한 방법을 제공하고, 소프트웨어 품질에 대한 통찰력을 가지도록 돕니다.

## 지속적 배포 ( Continuous Delivery)
- 모든 체크인의 실환경 준비에 대한 지속적인 피드백을 얻고, 나아가 모든 체크인을 빠짐없이 릴리스 후보로 여기는 접근방법이다.
- CD를 완벽하게 지원하는 도구는 소프트웨어의 실환경에 이르는 전체 경로를 모델링하면서 파이프라인들을 정의하고 시각화한다.
- 코드의 특정 버전은 파이프라인을 거칠 때 자동화된 검증 단계 중 하나를 통과하면 다음 단계로 이동한다. 다음 단계는 수동 검증일 수 있다.

## 플랫폼별 산출물
- 산출물을 배포하고 실행하기 위해 다른 소프트웨어를 설치하고 구성할 방법도 필요하다. 이를 위해 퍼펫, 셰프와 같은 자동화돈 구성 관리 도구가 필요하다.
- 특정 기술 스택에 한정되어 여러 기술이 혼용될 때 배포가 어려울 수 있다.
- 자동화는 하부 산출물의 배포 메커니즘의 차이를 감추는 데 크게 도움이 된다.

## 운영 체제 산출물
- 특정 기술에 제한적인 산출물과 관련된 문제를 피할 수 있는 한 가지 방법은 하부 운영 체제에 네이티브한 산출물을 생성하는 것이다. 
- 특정 OS별 산출물을 사용하는 이점은 배포의 관점에서 하부 기술에 신경 쓰지 않아도 된다는 것이다.
- 이 방식의 단점은 처음 패키지를 생성할 때 어려움이 있을 수 있으며, 다양한 운영 체제를 배포할 때 큰 부담이 된다.

## 커스텀 이미지
- 가동 시간을 줄이기 위하여 공통적으로 의존하는 것들을 주입한 가상 머신 이미지를 만든다.
- 공용 도구를 제차 이미지에 구워낼 수 있다.
- 만약 소프트웨어를 배포하기 원한다면 커스텀 이미지의 인스턴스를 가동시킨 후 서비스의 최신 버전을 설치하면 된다.
- 핵심적인 의존성이 변경되지 않는 한 새 버전의 서비스들은 동일한 원본 이미지를 계속 사용할 수 있다.
- 이 방법의 단점은 이미지 생성 시간이 오래 걸리고 생성된 이미지가 매우 크다.
- 이러한 단점을 회피할 수 있는 컨테이너 기술은 도커(Docker)이다.
- 패커(Packer :packer.io)는 이미지를 훨씬 쉽게 만들기 위해 고안된 도구다. 선택한 환경 구성 스크립트를 사용하여 동일한 환경 구성으로 다양한 플랫폼 이미지를 생성할 수 있다.
- 환경 구성 불일치 문제가 발생하지않으려면 실행 중인 서버에 어떤한 변경도 하지않아야 하며, 아주 작은 변경이더라도 새로운 머신을 생성하기 위해서는 빌드 파이프라인을 통해야한다.


