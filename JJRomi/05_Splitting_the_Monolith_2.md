# CHAPTER 5. Splitting the Monolith 

## 트랜잭션의 경계
- 트랜잭션은 이벤트가 모두 발생하거나 전혀 발생하지 않게 해준다. 
- 데이터의 불일치 상태를 피할 수 있기 때문에 데이터베이스에 데이터를 입력할 때 매우 유용하다.
- 연산의 일부를 큐나 로그 파일에 큐잉하여 나중에 재시도를 할 수 있다.
- 트랜잭션 경계를 사용하는 대신 향후 특정 시점에시스템이 스스로 일관성을 유지하는 상태가 될 수 있음을 허용한다. 
(트랜잭션이 완료되었을때 시스템이 일관성을 유지하는 상태임을 보장하기 위함)
- _보장트랜잭션_ : 직전의 트랜잭션을 되돌릴 새로운 트랜잭션을 발생시키는 것
- _분산트랜잭션_ : 보상 트랜잭션을 수동으로 통제하는 방식의 대안으로 전체적인 통제 프로세스를 사용해서 트랜잭션 내부의 여러 트랜잭션을 확장하려 노력한다.
  - 범용적 알고리즘 : 2단계 커밋 (two-phase commit) 트랜잭션 매니저가 반대표를 하나라도 받는다면 모든 참여자가 롤백하는 것

## 리포팅 데이터베이스
- 일반적인 모놀리식 서비스 아키텍처에서 모든 데이터는 거대한 단일 데이터베이스에 저장된다.
- 리포팅 시스템은 대게 읽기용 복제 데이터베이스에 연결한다.
- 스키마 변경은 조심스럽게 관리되어야하며, 스키마를 변경하고 조율할 기회를 줄이는 방해물이 되기도 한다.
- 실제 시스템 또는 리포팅 시스템을 지원하는 사용 사례를 위해 데이터베이스를 최적화하는 방법이 제한적이다.

## 서비스 호출을 통한 데이터 추출
- 모두 원본 시스템으로부터 API를 통한 데이터 추출에 의존한다.
- 리포팅 시스템에 사용하려한 API가 아니므로 데이터를 추출하기 위해 많은 API를 호출해야하는 경우가 있어 비효율적일 뿐만 아니라 해당 서비스에도 부하가 될 수 있다.
- 아무도 이전에 요청하지 않았던(적어도 아주 오래 전에 요청한) 자원을 요청할 수 있으며 이로 인해 잠재적으로 연산 비용이 높은 캐시 미스가 발생한다.

## 데이터 펌프
- 데이터를 끌어오는 방식 대신 리포팅 시스템에 데이터를 밀어 넣는 방식을 시도할 수 있다.
- 합리적이고 실행 가능한 제안이지만 데이터베이스 내부 변경을 관리하는 어려움이 있어 분할된 스키마의 복잡성을 감수할 가치가 있는지 생각해야한다.

## 이벤트 데이터 펌프
- 이벤트가 발생할 때 리포팅 시스템에 데이터를 보낼 수 있으므로 정기적으로 데이터를 밀어 넣는 것보다 더 신속하게 데이터가 리포팅 시스템에 흘러들어갈 수 있다.
- 이미 처리된 이벤트를 저장한다면 오래된 이벤트가 이미 리포팅 시스템에 매핑되었다고 가정하고 새로운 이벤트가 도착할 때 그것만 처리하면 된다.
- 필요한 모든 정보를 이벤트로 확산해야하는 단점이 있다.
- 데이터베이스 레벨에서 바로 수행될 때 유리한 대용량의 데이터를 위한 데이터 펌프는 불가능하다.

## 백업 데이터 펌프
- 데이터 파일을 복사해서 안전한 곳에 저장하는 것이다.

## 변경 비용
- 데이터베이스를 분리하는 것은 더 많은 작업이 필요하고 변경을 되돌리는 것은 복잡한 일이다.
- 서비스들이 지나치게 결합된 통합을 분리하는 것 또는 다수의 소비자가 사용하는 API를 완전히 재작성하는 것은 상당히 큰 작업이다.
- 가장 영향도가 낮은 실수부터 시도하는 것이 좋다.
- CRC(Class Reponsibility Cikkabiration)** 카드를 이용하여 접근 추천

----
 CRC(Class Reponsibility Cikkabiration)** : 색인카드에 클래스의 이름 그것의 책임, 누구와 협업하는지 기입한다. 제안된 디자인을 통해 작업할 때 필자는 각각의 서비스에 대해
 그것이 제공하는 기능 측면에서의 책임과 다이어그램에 지정된 협업자를 나열한다. 더 많은 사용 사례를 통해 작업할 때 이 모든 것이 적절히 들어맞는지 감을 잡을 수 있을 것이다.
 
