# CHAPTER 7. Testing
> 테스팅은 소프트웨어를 가능한 한 빨리 실환경에 적용하려는 세력과 소프트웨어의 충분한 품질을 보자하려는 세력 사이의 균형을 유지하기 위해 중요하다.

## 테스트의 종류 ( 애자일 테스팅 : 테스터와 애자일 팀을 위한 실용가이드 발췌 )
- 인수 테스팅
  - 우리는 옳을 것을 빌드했는가? 자동화 (Fit-Finesse 등) 
  - 비즈니스중심, 프로그래밍 지원
- 탐색 테스팅 
  - 사용성 :  어떻게 시스템에 장애를 만들 수 있을까? 수동
  - 비즈니스 중심, 제품 평가
- 단위 테스팅 
  - 우리는 제대로 빌드했는가 ? 자동화 (xUnit 프레임워크)
  - 기술 중심, 프로그래밍 지원
- 속성 테스팅 
  - 응답 시간, 확장성, 성능, 보안
  - 기술 중심 , 제품 평가
- 시스템을 구축할 때 개발자를 도와주는 테스트인 성능테스트와 좁은 범위의 단위 테스트는 일반적으로 모두 자동화 된다.
- 최근 추세는 가능한 많은 자동화를 추구해 대규모 수동 테스트를 탈피하는 것이다.
- 현재 대규모 수동 테스트를 수행한다면 마이크로서비스의 길에 더 진입하기 전에 그 문제부터 해결해야한다.

## 테스트의 범위
- 마이크 콘의 테스트 피라미드 ( 경험과 사례롤 풀어낸 성공하는 애자일 발췌 )는 자동와 테스트를 단위( Unit )- 서비스( Service ) - UI순으로 분리한다. 단위로 갈수로 더 빠른, 더 많은 격리를 하며 UI로 갈수록 테스트 범위의 증가와 더 많은 확신을 요구한다.
- 단위 테스트 
  - 일반적으로 단일 함수 또는 메시드 호출을 테스트하는 것이다.
  - 테스트 주도 설계 (TDD)의 부산물로 생성된 테스트는 이 범주에 속할 것이다.
  - 비즈니스 중심이기보다는 기술 중심이라 할 수 있다. 
  - 핵심 목표는 기능의 정상 동작 유무에 대한 매우 빠른 피드백이다.
  - 작업을 진행하면서 코드를 재구성하게 해주며, 작은 범위의 테스트들이 우리의 실수를 잡아주기때문에 코드의 리팩토링을 지원하는 데 있어 중요하다.
- 서비스 테스트
  - 사용자 인터페이스를 우회해서 서비스들을 직접 테스트한다. 
  - 모놀리식 애플리케이션에서는 UI에 서비스를 제공하는 클래스의 집합만 테스트 할 수 있다.
  - 여러 서비스로 구성된 시스템에 대해 서비스 테스트는 개별 서비스의 기능을 테스트할 수 있다.
  - 단위테스트보다 테스트 시간 뿐 아니라 테스트가 실패할 경우 어떤 부분이 장애를 만들었는지 단위 테스트보다 찾기 더 어려울 것이다. 하지만 서비스 테스트는 변경되는 부분이 훨씬 적으므로 넓은 범위의 테스트보다 덜 취약하다.
- 엔드 투 엔드 테스트 (UI 테스트)
  - 시스템 전체에 대해 수행하는 테스트이다.
  - 대개 브라우저를 통해 GUI를 접하지만, 파일 업로드와 같은 다른 종류의 사용자 상호작용을 쉽게 흉내 낼 수 있다.
  - 수많은 실환경의 코드 테스팅을 포함하기 때문에 테스트를 통과하면 테스트된 코드가 실환경에서 잘 동작할 것이라는 강한 확신과 함께 안심할 수 있다.
  - 테스트를 제대로 수행하는 것은 마이크로서비스 환경에서 매우 까다로운 일이다.
- 절충안
  - 다른 목적을 위해 다른 범위의 테스트가 필요하다.
  - 얼마나 많은 테스트가 필요할까?
  - 일반적인 안티패턴**은 테스트 아이스크림콘이나 역피라미드로 언급된다. 이 패턴은 작은 범위의 테스트가 거의 없고 대부분 큰 범위의 테스트로 이루어져있다. 이러한 프로젝튿들은 빙하처럼 느린 테스트와 아주 긴 피드백 주기를 가진다. 
  
## 서비스 테스트 구현하기
- 서비스 테스트 집합은 하위 협업자를 위한 스텁 서비스를 실행시켜야 하고(또는 그들이 실행되는 것을 보장하고) 스텁 서비스들과 연결되는 환경에 고객 서비스를 구성해야 한다.그런 다음 실환경 서비스를 모방해 응답을 보내도록 스텁을 구성해야한다.
- 목 도는 스텁 사용하기
  - 하위 협업자의 스텁 생성을 이야기할 때는 테스트 대상의 서비스가 알려진 요청을 보내면 정해진 응답을 하는 스텁 서비스를 생성함을 의미한다. 
  - 목을 사용할 때는 실제로 더 나아가 호출의 수행까지 보장된다. 예상된 호출이 이루어지지 않으면 테스트는 실패한다. 스텁은 0, 1  또는 여러 번의 호출은 상관하지않는다. 이 방법의 구현은 더 많은 영리함을 필요로 하고 남용되면 테스트를 취약하게 만든다.
  - 목은 예상된 부작용이 발생하는지 확인하는 데 매우 유용하다. 
  - 스텁과 목 호출 사이의 균형은 민감한 것이라서 단위 테스트 처럼 서비스 테스트에서도 까다롭니다. 따라서 일반적으로 서비스 테스트를 위해 목보다 스텁을 사용한다.

## 까다로운 엔드 투 엔드 테스트
- 시스템의 전체적인 관점을 제공하기 위해 사용자 인터페이스를 통해 시스템 하부의 모든 기능을 동작시키는 것이다.
- 엔드 투 엔드 테스트를 구현하기 위해 다수의 서비스를 함께 배포해야하고, 그 후 모든 서비스에 대한 테스트를 수행해야한다.
- 엔드 투 엔드 테스트를 추가하기 전 두 가지 질문을 고려해야한다.
  - 1. 다른 서비스의 어떤 버전을 사용해야하는 가? 실환경의 현재 버전을 수행하는 것이 합리적이지만 만약 새 버전이 나올 것이라면?
  - 2. 다른 서비스가 수행하는 엔드 투 엔드 테스트는 어떻게 될까? 서비스 테스트와 엔드 투 엔드 테스트가 같은 것을 테스트한다면 동일한 많은 부분을 다루고 있음을 알게 되고, 모든 서비스를 처음 배포하기 위해 많은 노력이 중복될 수 있다.
  - 이 두 문제는 여러 서비스의 파이프라인을 단일 엔드 투 엔드 테스트 단계로 수렴(fan-in)하여 세련되게 처리할 수 있다. 서비스가 변경되면 언제라도 그 서비스에 대한 로컬 테스트를 수행할 수 있다. 그 테스트들이 통과되면 통합 테스트를 시작하는 것이다.

## (엔드 투 엔드 테스팅의 단점)신뢰할 수 없고 취약한 테스트
- 테스트 범위가 증가함에 따라 변경되는 부분 역시 증가한다. 
- 서비스들 중 하나라도 다운된다면 테스트 자체와 관련 없이 결과적으로 실패할 것이다.
- 임시적인 네트워크 장애는 테스트 중인 기능에 대해 어떤 알림도 없이 테스트를 실패하게 만들 수 있다.
- 변경되는 부분이 많으면 많을 수록 테스트는 취약해지고 비결정적(non-deterministic)이 된다.
- 가끔 실패하지만 재실행하면 성공하는 테스트는 신뢰할 수 없는 테스트이다.
- 신뢰할 수 없는 테스트를 가진 테스트 집합은 다이안보건의 비정상의 정상화, 즉 시간이 지나면서 정상이며 문제가 아니라고 받아들이기 시작한 잘못에 우리가 매우 익숙해질 수 있다는 개념의 희생자가 될 수 있다.
- 누가 이 테스트를 작성하는가?
  - 다수의 팀이 연계되어 있고 엔드 투 엔드 테스트 단걔가 여러 팀 사이에 효과적으로 공유되어 있다면 누가 이 테스트를 작성하고 돌봐야 할까?
  - 최고의 균형은 엔드 투 엔드 테스트 집합을 공동 소유의 공유 코드 베시으로 다루는 것이다. 팀들은 여기에 자유롭게 체크인하지만 테스트 집합의 건강 상태에 대한 책임은 서비스를 직접 개발한 팀 사이에 공유되어야 한다.
- 얼마나 오래 걸릴까?
  - 테스트 느림은 종종 이들 테스트를 신뢰할 수 없다는 사실과 합쳐져서 중대한 문제가 될 수 있다. 
  - 테스트를 병렬로 실행하여 문제 일부를 개선할 수 있다. 하지만 이 방법이 무엇을 테스트해야하는 지 실제로 이행하고 더 이상 필요없는 테스트를 적극적으로 제거하는 것을 대신할 수는 없다.
  - 테스트를 제거한 것이 버그를 통과시켰다면 비난받을 것은 확실하다. 사람들이 잘못하기로 유명한 위험에 대한 깊은 이해가 필요하다. 
- 엄청난 적체
  - 모든 테스트를 성공적으로 통과한 소프트웨어만 배포한다면 실환경에 배포될 수 있는 서비스가 매우 적어진다는 것을 의미한다.
  - 중단된 통합 테스트 단계를 고치는 동안 상위 팀으로부터 더 많은 변경이 유입된다. 
  - 엔드 투 엔드 테스트가 실패할 경우 사람들의 체크인을 금지시키는 것이다. 그러나 긴 시간이 필요한 테스트 집합의 경우라면 현실적이지 못한 방법이다.
  - 소프트웨어를 자주 릴리스할 수 있는 주요 원동력은 작은 변경이 준비되는 대로 릴리스 한다는 생각에 기반을 둔다.
- 메타버전
  - 여러 서비스에 적용된 변경들을 함께 버전 관리함으로써 우리는 그 서비스들의 변경과 배포가 동시에 가능하다는 아이디어를 효과적으로 받아들인다.
  - 일반적으로 괜찮은 방법이지만, 그렇게 함으로써 마이크로서비스의 주요 혜택인 서비스를 다른 서비스와 독립적을 배포하는 능력을 잃어버리게 된다.
  - 단일 모놀로식 애플리케이션 때보다 더 나쁜 상황에 처하게 된다.
  
## (엔드 투 엔드 테스팅의 단점)스토리가 아닌 테스트 여정
- 모든 새로운 스토리에 새로운 엔드 투 엔드 테스트를 추가한다면 결국 긴 피드백 주기와 테스트 범위가 크게 중복된 비대한 테스트 집합을 초래할 것이다. 
- 이 문제에 대응하는 최선의 방법은 전체 시스템을 테스트하는 소수의 핵심적인 여정에 집중하는 것이다.
- 이 여정은 상호 합의되어야하고 공동 소유여야 한다.
- 소수(여기서 소스는 복잡한 시스템이더라도 매우 낮은 두 자리 숫자를 의미한다)의 테스트에 집중함으로써 통합 테스트의 단점을 줄일 수 있지만, 모두 없애지는 못한다.

## 우리를 구한 소비자 주도 테스트
- 소비자 주도 계약 (Consumer-Driven Contract :CDC)를 사용하는 것이다.
- CDC를 통해 서비스 (또는 생산자)에 대한 소비자의 기대 사항을 정의한다. 소비자의 기대 사항은 테스트로서 코드 형태로 표현되고 그 테스트는 생산자에 대해 수행된다.
- 테스트 피드백 관점에서 매우 중요한 점은 이들 테스트는 하나의 생산자만 격리해서 수행되어야 한다는 것이다. 그러면 대체할 엔드 투 엔드 테스트보다 더 빠르고 더 신뢰할 수 있는 테스트가 될 수 있다.
- 소비자가 어떻게 서비스를 사용하는지에 중점을 두며, 테스트가 깨졌을 때 시작하는 방식은 서비스 테스트와 매우 다르다.
- CDC를 통해 고비용일 수 있는 엔드 투 엔드 테스트를 수행하지 않고도 소프트웨어가 실환경에 이르기 전에 호환성을 깨뜨리는 변경을 발견할 수 있다.
- 팩트 
  - 팩트는 베스 스커리**가 개발한 소비자 주도 테스팅 도구로 내부용으로 개발했으마 현재는 오픈 소스가 되었다. 처음에는 루비만 지원했으며 현재는 JVM과 .NET으로도 포팅되었다.
  - 소비자는 루비 DSL을 사용하여 생산자에 대한 기대 사항을 정의하는 것부터 시작한다. 그 다음에 로컬 목 서버를 실행하고 팩트 명세서 파일을 생성하기 위해 그 서버에서 기대사항을 실행한다. 팩트 파일은 JSON형식의 명세서로, 직접 작성할 수도 있지만 언어 API를 사용하는 편이 훨씬 쉽다. 이는 앞으로 더 격리될 소비자 테스트에 사용될 수 있는 목 서버도 제공한다.
  - 생산자 측면에서는 JSON 팩트 명세서를 이용하여 소비자 명세서가 생산자의 API를 호풀하고 응답하는지 검증한다.
  - JSON 팩트 명세서는 소비자에 의해 생성되기 때문에 생산자 빌드가 접근할 수 있는 산출물이 될 필요가 있다. CI/CD 도구가 사용하는 산출물 저장소에 이것을 저장할 수 있고, 여러버전의 팩트 명세서를 저장할 수 있는 팩트 중걔자를 사용할 수 있다.
- 대화에 관하여
  - 애자일에서는 스토리는 CDC처럼 대화의 표식(placeholder)으로 흔히 언급된다. 스토리는 서비스 API가 어떻게 보여야 하는징 대한 논의를 체계화한다. 스토리가 망가질 때가 API가 어떻게 개선해야 하는지 이야기할 시발점이 된다.
  - CDC가 소비자와 생산자 간의 훌륭한 커뮤니케이션과 신뢰를 필요로 한다는 사실을 이해하는 것이 중요하다.

## 엔드 투 엔드 테스트를 사용해야 하는가?
- 실환경 시스템을 모니터링하기 위해 유의적 모니터링(semantic monitoring)이라는 기술을 사용하는 데 많은 엔드 투 엔드 테스트를 사용한다. 

## 출시 후의 테스팅
- 배포 전의 테스팅을 통해서는 장애의 가능성을 완전히 없앨 수 없다.
- 배포를 릴리스와 분리하기
  - 테스트를 수행할 단계를 전통적인 배포 전 단계를 넘어 확장하는 것이다. 
  - 일반적인 예는 스모그 테스트(smoke test)**다. 이는 제대로 배포되었는지 보장하기 위해 새롭게 배포된 소프트웨어에 대해 수행하도록 설계된 테스트의 집합이다. 이 테스트는 지역적 환경 문제를 발견하는 데 도움이 된다. 
  - 또 다른 예는 청색/녹생 배포(blue/green deployment)로, 동시에 배포된 두 개의 소프트웨어 복제본 중에서 한 버전만 실제 요청을 처리한다. 만약 에러가 발생하면 신속한 되돌림을 위해 이전 버전을 짧은 기간동안 유지하는 것이 일반적이다.
  - 실환경 트래픽을 다른 호스트로 향하게 할 수 있어야한다.
  - 한번에 두 버전의 마이크로서비스를 프로비저닝할 수 있어야한다.
  - 배포의 위험을 낮출 뿐 아니라 문제가 발생했을때 되돌릴 기회를 준다.
  - 이 방식이 능숙하다면 전체 프로세스가 사람 개입없이 모든 전개와 복귀가 자동화 될 수 있다.
- 카나리아 릴리스 
  - 버전들을 더 오래 공존시킬 수 있고 트래픽의 양을 자주 변경할 수 있다는 점에서 청색/녹색 릴리스와 차이가 있다.
  - 실환경 요청의 일정 부분을 카나리아 릴리스로 우회할 것인지 또는 실환경 부하를 복제할 것인지 결정해야한다.
  - 반복되는 이벤트/요청이 멱등적이지 않더라도 실환경 트래픽을 추적하는 작업은 복잡할 수 있다.
  - 새로운 릴리스의 동작을 확신하기 위해 트래픽 비율을 조정해야 하기 때문에 더 정교한 트래픽 라우팅도 필요하다.
- MTBF보다 MTTR?
  - 때로는 자동화된 기능 테스트를 더 추가하는 것보다 릴리스를 보수하는 데 같은 노력을 쏘는 것이 훨씬 더 유익할 수 있다. 웹 운영 분야에서 이것은 대개 평균 무고장 시간(MTBF : Mean Time Between Failures)과 평균 수리 시간(MTTR : Mean Time To Repair)사이의 최적화에 대한 균형으로 언급된다.
  - 다양한 조직에서 MTBF와 MTTR사이의 균형점은 다르며, 균형점 대부분은 실환경에서 장애의 실질적 영향에 대한 이해와 함께 한다. 

## 교차기능 테스트
- 비기능적 요구 사항은 일반적인 기능과 같이 단순히 구현될 수 없는 시스템의 특징을 기술하는 데 사용되는 포괄적 용어이다. 
- 그 요구 사항은 웹 페이지의 허용 가능한 지연시간, 시스템이 지원해야하는 사용자 수 , 사용자 인터페이스가 장애인에게 얼마나 이해하기 쉬운지 또는 고객 데이터가 얼마나 안전한지와 같은 측면을 다룬다.
- 교차기능요구사항(CFR : Cross-Functional Requirements)이라는 용어를 대신 고안했다. 
- 이런 종류의 테스트는 속성 테스팅 분면에 속한다.
- 아주 뒤늦게 CFR을 고려하는 일이 빈번하다. 가능한 일찍 CFR을 살펴보고 정기적으로 검토하기를 강력히 제안한다.
- 성능 테스트
  - 모놀리식 시스템일 때보다 애플리케이션의 성능을 테스트하는 방법이 훨씬 중요하다.
  - 시스템의 핵심 기능을 확인하는 테스트부터 시작해야한다.
  - 실환경처럼 더 많은 양의 데이터가 필요하고 인프라스트럭처를 일치키기위해 더 많은 머신이 필요하다.
  - 성능테스트 환경을 정말로 실환경처럼 만들려고 애쓸지라도 병목현상의 추적에 있어 그 테스트는 여전히 가치 있을 것이다. 단지 테스트 결과가 거짓 부정 또는 더 나쁜 경우 거짓 긍정 에러가 발생할 수 있음을 명심하다. 
  - 성능 테스트의 수행에는 시간이 소요되므로 모든 체크인마다 항상 수행할 수는 없다.
  - 그중 작은 집합은 매일, 큰 집합은 매주 수행하는 것이 일반적인 관례다.
  - 새롭게 출현하는 문제를 발견하기 위해 확인해야 할 커밋의 수를 줄이는 것이 좋다.
  - 목표 수치를 설정하고 그 결과를 기반으로 적색 또는 녹색 빌드로 진행하는 것이 좋다.
  - 실제 시스템의 성능 모니터링을 지원받아 수행되어야하며 성능 테스트 환경에서도 같은 도구를 사용해야한다.
